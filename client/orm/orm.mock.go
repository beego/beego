// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/stone/go_project/beego/beego/client/orm/types.go

// Package ormmocks is a generated GoMock package.
package orm

import (
	context "context"
	sql "database/sql"
	reflect "reflect"
	time "time"

	order_clause "github.com/beego/beego/v2/client/orm/clauses/order_clause"
	models "github.com/beego/beego/v2/client/orm/internal/models"
	utils "github.com/beego/beego/v2/core/utils"
	gomock "go.uber.org/mock/gomock"
)

// MockTableNameI is a mock of TableNameI interface.
type MockTableNameI struct {
	ctrl     *gomock.Controller
	recorder *MockTableNameIMockRecorder
}

// MockTableNameIMockRecorder is the mock recorder for MockTableNameI.
type MockTableNameIMockRecorder struct {
	mock *MockTableNameI
}

// NewMockTableNameI creates a new mock instance.
func NewMockTableNameI(ctrl *gomock.Controller) *MockTableNameI {
	mock := &MockTableNameI{ctrl: ctrl}
	mock.recorder = &MockTableNameIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTableNameI) EXPECT() *MockTableNameIMockRecorder {
	return m.recorder
}

// TableName mocks base method.
func (m *MockTableNameI) TableName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableName")
	ret0, _ := ret[0].(string)
	return ret0
}

// TableName indicates an expected call of TableName.
func (mr *MockTableNameIMockRecorder) TableName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableName", reflect.TypeOf((*MockTableNameI)(nil).TableName))
}

// MockTableEngineI is a mock of TableEngineI interface.
type MockTableEngineI struct {
	ctrl     *gomock.Controller
	recorder *MockTableEngineIMockRecorder
}

// MockTableEngineIMockRecorder is the mock recorder for MockTableEngineI.
type MockTableEngineIMockRecorder struct {
	mock *MockTableEngineI
}

// NewMockTableEngineI creates a new mock instance.
func NewMockTableEngineI(ctrl *gomock.Controller) *MockTableEngineI {
	mock := &MockTableEngineI{ctrl: ctrl}
	mock.recorder = &MockTableEngineIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTableEngineI) EXPECT() *MockTableEngineIMockRecorder {
	return m.recorder
}

// TableEngine mocks base method.
func (m *MockTableEngineI) TableEngine() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableEngine")
	ret0, _ := ret[0].(string)
	return ret0
}

// TableEngine indicates an expected call of TableEngine.
func (mr *MockTableEngineIMockRecorder) TableEngine() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableEngine", reflect.TypeOf((*MockTableEngineI)(nil).TableEngine))
}

// MockTableIndexI is a mock of TableIndexI interface.
type MockTableIndexI struct {
	ctrl     *gomock.Controller
	recorder *MockTableIndexIMockRecorder
}

// MockTableIndexIMockRecorder is the mock recorder for MockTableIndexI.
type MockTableIndexIMockRecorder struct {
	mock *MockTableIndexI
}

// NewMockTableIndexI creates a new mock instance.
func NewMockTableIndexI(ctrl *gomock.Controller) *MockTableIndexI {
	mock := &MockTableIndexI{ctrl: ctrl}
	mock.recorder = &MockTableIndexIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTableIndexI) EXPECT() *MockTableIndexIMockRecorder {
	return m.recorder
}

// TableIndex mocks base method.
func (m *MockTableIndexI) TableIndex() [][]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableIndex")
	ret0, _ := ret[0].([][]string)
	return ret0
}

// TableIndex indicates an expected call of TableIndex.
func (mr *MockTableIndexIMockRecorder) TableIndex() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableIndex", reflect.TypeOf((*MockTableIndexI)(nil).TableIndex))
}

// MockTableUniqueI is a mock of TableUniqueI interface.
type MockTableUniqueI struct {
	ctrl     *gomock.Controller
	recorder *MockTableUniqueIMockRecorder
}

// MockTableUniqueIMockRecorder is the mock recorder for MockTableUniqueI.
type MockTableUniqueIMockRecorder struct {
	mock *MockTableUniqueI
}

// NewMockTableUniqueI creates a new mock instance.
func NewMockTableUniqueI(ctrl *gomock.Controller) *MockTableUniqueI {
	mock := &MockTableUniqueI{ctrl: ctrl}
	mock.recorder = &MockTableUniqueIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTableUniqueI) EXPECT() *MockTableUniqueIMockRecorder {
	return m.recorder
}

// TableUnique mocks base method.
func (m *MockTableUniqueI) TableUnique() [][]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableUnique")
	ret0, _ := ret[0].([][]string)
	return ret0
}

// TableUnique indicates an expected call of TableUnique.
func (mr *MockTableUniqueIMockRecorder) TableUnique() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableUnique", reflect.TypeOf((*MockTableUniqueI)(nil).TableUnique))
}

// MockIsApplicableTableForDB is a mock of IsApplicableTableForDB interface.
type MockIsApplicableTableForDB struct {
	ctrl     *gomock.Controller
	recorder *MockIsApplicableTableForDBMockRecorder
}

// MockIsApplicableTableForDBMockRecorder is the mock recorder for MockIsApplicableTableForDB.
type MockIsApplicableTableForDBMockRecorder struct {
	mock *MockIsApplicableTableForDB
}

// NewMockIsApplicableTableForDB creates a new mock instance.
func NewMockIsApplicableTableForDB(ctrl *gomock.Controller) *MockIsApplicableTableForDB {
	mock := &MockIsApplicableTableForDB{ctrl: ctrl}
	mock.recorder = &MockIsApplicableTableForDBMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIsApplicableTableForDB) EXPECT() *MockIsApplicableTableForDBMockRecorder {
	return m.recorder
}

// IsApplicableTableForDB mocks base method.
func (m *MockIsApplicableTableForDB) IsApplicableTableForDB(db string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsApplicableTableForDB", db)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsApplicableTableForDB indicates an expected call of IsApplicableTableForDB.
func (mr *MockIsApplicableTableForDBMockRecorder) IsApplicableTableForDB(db interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicableTableForDB", reflect.TypeOf((*MockIsApplicableTableForDB)(nil).IsApplicableTableForDB), db)
}

// MockDriver is a mock of Driver interface.
type MockDriver struct {
	ctrl     *gomock.Controller
	recorder *MockDriverMockRecorder
}

// MockDriverMockRecorder is the mock recorder for MockDriver.
type MockDriverMockRecorder struct {
	mock *MockDriver
}

// NewMockDriver creates a new mock instance.
func NewMockDriver(ctrl *gomock.Controller) *MockDriver {
	mock := &MockDriver{ctrl: ctrl}
	mock.recorder = &MockDriverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDriver) EXPECT() *MockDriverMockRecorder {
	return m.recorder
}

// Name mocks base method.
func (m *MockDriver) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockDriverMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockDriver)(nil).Name))
}

// Type mocks base method.
func (m *MockDriver) Type() DriverType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(DriverType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockDriverMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockDriver)(nil).Type))
}

// MockTxBeginner is a mock of TxBeginner interface.
type MockTxBeginner struct {
	ctrl     *gomock.Controller
	recorder *MockTxBeginnerMockRecorder
}

// MockTxBeginnerMockRecorder is the mock recorder for MockTxBeginner.
type MockTxBeginnerMockRecorder struct {
	mock *MockTxBeginner
}

// NewMockTxBeginner creates a new mock instance.
func NewMockTxBeginner(ctrl *gomock.Controller) *MockTxBeginner {
	mock := &MockTxBeginner{ctrl: ctrl}
	mock.recorder = &MockTxBeginnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxBeginner) EXPECT() *MockTxBeginnerMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockTxBeginner) Begin() (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockTxBeginnerMockRecorder) Begin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockTxBeginner)(nil).Begin))
}

// BeginWithCtx mocks base method.
func (m *MockTxBeginner) BeginWithCtx(ctx context.Context) (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginWithCtx", ctx)
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithCtx indicates an expected call of BeginWithCtx.
func (mr *MockTxBeginnerMockRecorder) BeginWithCtx(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithCtx", reflect.TypeOf((*MockTxBeginner)(nil).BeginWithCtx), ctx)
}

// BeginWithCtxAndOpts mocks base method.
func (m *MockTxBeginner) BeginWithCtxAndOpts(ctx context.Context, opts *sql.TxOptions) (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginWithCtxAndOpts", ctx, opts)
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithCtxAndOpts indicates an expected call of BeginWithCtxAndOpts.
func (mr *MockTxBeginnerMockRecorder) BeginWithCtxAndOpts(ctx, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithCtxAndOpts", reflect.TypeOf((*MockTxBeginner)(nil).BeginWithCtxAndOpts), ctx, opts)
}

// BeginWithOpts mocks base method.
func (m *MockTxBeginner) BeginWithOpts(opts *sql.TxOptions) (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginWithOpts", opts)
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithOpts indicates an expected call of BeginWithOpts.
func (mr *MockTxBeginnerMockRecorder) BeginWithOpts(opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithOpts", reflect.TypeOf((*MockTxBeginner)(nil).BeginWithOpts), opts)
}

// DoTx mocks base method.
func (m *MockTxBeginner) DoTx(task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTx", task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTx indicates an expected call of DoTx.
func (mr *MockTxBeginnerMockRecorder) DoTx(task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTx", reflect.TypeOf((*MockTxBeginner)(nil).DoTx), task)
}

// DoTxWithCtx mocks base method.
func (m *MockTxBeginner) DoTxWithCtx(ctx context.Context, task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxWithCtx", ctx, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithCtx indicates an expected call of DoTxWithCtx.
func (mr *MockTxBeginnerMockRecorder) DoTxWithCtx(ctx, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithCtx", reflect.TypeOf((*MockTxBeginner)(nil).DoTxWithCtx), ctx, task)
}

// DoTxWithCtxAndOpts mocks base method.
func (m *MockTxBeginner) DoTxWithCtxAndOpts(ctx context.Context, opts *sql.TxOptions, task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxWithCtxAndOpts", ctx, opts, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithCtxAndOpts indicates an expected call of DoTxWithCtxAndOpts.
func (mr *MockTxBeginnerMockRecorder) DoTxWithCtxAndOpts(ctx, opts, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithCtxAndOpts", reflect.TypeOf((*MockTxBeginner)(nil).DoTxWithCtxAndOpts), ctx, opts, task)
}

// DoTxWithOpts mocks base method.
func (m *MockTxBeginner) DoTxWithOpts(opts *sql.TxOptions, task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxWithOpts", opts, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithOpts indicates an expected call of DoTxWithOpts.
func (mr *MockTxBeginnerMockRecorder) DoTxWithOpts(opts, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithOpts", reflect.TypeOf((*MockTxBeginner)(nil).DoTxWithOpts), opts, task)
}

// MockTxCommitter is a mock of TxCommitter interface.
type MockTxCommitter struct {
	ctrl     *gomock.Controller
	recorder *MockTxCommitterMockRecorder
}

// MockTxCommitterMockRecorder is the mock recorder for MockTxCommitter.
type MockTxCommitterMockRecorder struct {
	mock *MockTxCommitter
}

// NewMockTxCommitter creates a new mock instance.
func NewMockTxCommitter(ctrl *gomock.Controller) *MockTxCommitter {
	mock := &MockTxCommitter{ctrl: ctrl}
	mock.recorder = &MockTxCommitterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxCommitter) EXPECT() *MockTxCommitterMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockTxCommitter) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTxCommitterMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTxCommitter)(nil).Commit))
}

// Rollback mocks base method.
func (m *MockTxCommitter) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTxCommitterMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTxCommitter)(nil).Rollback))
}

// RollbackUnlessCommit mocks base method.
func (m *MockTxCommitter) RollbackUnlessCommit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackUnlessCommit")
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackUnlessCommit indicates an expected call of RollbackUnlessCommit.
func (mr *MockTxCommitterMockRecorder) RollbackUnlessCommit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackUnlessCommit", reflect.TypeOf((*MockTxCommitter)(nil).RollbackUnlessCommit))
}

// Mocktxer is a mock of txer interface.
type Mocktxer struct {
	ctrl     *gomock.Controller
	recorder *MocktxerMockRecorder
}

// MocktxerMockRecorder is the mock recorder for Mocktxer.
type MocktxerMockRecorder struct {
	mock *Mocktxer
}

// NewMocktxer creates a new mock instance.
func NewMocktxer(ctrl *gomock.Controller) *Mocktxer {
	mock := &Mocktxer{ctrl: ctrl}
	mock.recorder = &MocktxerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocktxer) EXPECT() *MocktxerMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *Mocktxer) Begin() (*sql.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(*sql.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MocktxerMockRecorder) Begin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*Mocktxer)(nil).Begin))
}

// BeginTx mocks base method.
func (m *Mocktxer) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx", ctx, opts)
	ret0, _ := ret[0].(*sql.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MocktxerMockRecorder) BeginTx(ctx, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*Mocktxer)(nil).BeginTx), ctx, opts)
}

// MocktxEnder is a mock of txEnder interface.
type MocktxEnder struct {
	ctrl     *gomock.Controller
	recorder *MocktxEnderMockRecorder
}

// MocktxEnderMockRecorder is the mock recorder for MocktxEnder.
type MocktxEnderMockRecorder struct {
	mock *MocktxEnder
}

// NewMocktxEnder creates a new mock instance.
func NewMocktxEnder(ctrl *gomock.Controller) *MocktxEnder {
	mock := &MocktxEnder{ctrl: ctrl}
	mock.recorder = &MocktxEnderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxEnder) EXPECT() *MocktxEnderMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MocktxEnder) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MocktxEnderMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MocktxEnder)(nil).Commit))
}

// Rollback mocks base method.
func (m *MocktxEnder) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MocktxEnderMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MocktxEnder)(nil).Rollback))
}

// RollbackUnlessCommit mocks base method.
func (m *MocktxEnder) RollbackUnlessCommit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackUnlessCommit")
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackUnlessCommit indicates an expected call of RollbackUnlessCommit.
func (mr *MocktxEnderMockRecorder) RollbackUnlessCommit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackUnlessCommit", reflect.TypeOf((*MocktxEnder)(nil).RollbackUnlessCommit))
}

// MockDML is a mock of DML interface.
type MockDML struct {
	ctrl     *gomock.Controller
	recorder *MockDMLMockRecorder
}

// MockDMLMockRecorder is the mock recorder for MockDML.
type MockDMLMockRecorder struct {
	mock *MockDML
}

// NewMockDML creates a new mock instance.
func NewMockDML(ctrl *gomock.Controller) *MockDML {
	mock := &MockDML{ctrl: ctrl}
	mock.recorder = &MockDMLMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDML) EXPECT() *MockDMLMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockDML) Delete(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockDMLMockRecorder) Delete(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockDML)(nil).Delete), varargs...)
}

// DeleteWithCtx mocks base method.
func (m *MockDML) DeleteWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx.
func (mr *MockDMLMockRecorder) DeleteWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*MockDML)(nil).DeleteWithCtx), varargs...)
}

// ExecRaw mocks base method.
func (m *MockDML) ExecRaw(ctx context.Context, md interface{}, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecRaw", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecRaw indicates an expected call of ExecRaw.
func (mr *MockDMLMockRecorder) ExecRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecRaw", reflect.TypeOf((*MockDML)(nil).ExecRaw), varargs...)
}

// Insert mocks base method.
func (m *MockDML) Insert(md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockDMLMockRecorder) Insert(md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockDML)(nil).Insert), md)
}

// InsertMulti mocks base method.
func (m *MockDML) InsertMulti(bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMulti", bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti.
func (mr *MockDMLMockRecorder) InsertMulti(bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*MockDML)(nil).InsertMulti), bulk, mds)
}

// InsertMultiWithCtx mocks base method.
func (m *MockDML) InsertMultiWithCtx(ctx context.Context, bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMultiWithCtx", ctx, bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMultiWithCtx indicates an expected call of InsertMultiWithCtx.
func (mr *MockDMLMockRecorder) InsertMultiWithCtx(ctx, bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMultiWithCtx", reflect.TypeOf((*MockDML)(nil).InsertMultiWithCtx), ctx, bulk, mds)
}

// InsertOrUpdate mocks base method.
func (m *MockDML) InsertOrUpdate(md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate.
func (mr *MockDMLMockRecorder) InsertOrUpdate(md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*MockDML)(nil).InsertOrUpdate), varargs...)
}

// InsertOrUpdateWithCtx mocks base method.
func (m *MockDML) InsertOrUpdateWithCtx(ctx context.Context, md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdateWithCtx indicates an expected call of InsertOrUpdateWithCtx.
func (mr *MockDMLMockRecorder) InsertOrUpdateWithCtx(ctx, md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateWithCtx", reflect.TypeOf((*MockDML)(nil).InsertOrUpdateWithCtx), varargs...)
}

// InsertWithCtx mocks base method.
func (m *MockDML) InsertWithCtx(ctx context.Context, md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertWithCtx", ctx, md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx.
func (mr *MockDMLMockRecorder) InsertWithCtx(ctx, md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*MockDML)(nil).InsertWithCtx), ctx, md)
}

// Raw mocks base method.
func (m *MockDML) Raw(query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Raw", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// Raw indicates an expected call of Raw.
func (mr *MockDMLMockRecorder) Raw(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Raw", reflect.TypeOf((*MockDML)(nil).Raw), varargs...)
}

// RawWithCtx mocks base method.
func (m *MockDML) RawWithCtx(ctx context.Context, query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RawWithCtx", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// RawWithCtx indicates an expected call of RawWithCtx.
func (mr *MockDMLMockRecorder) RawWithCtx(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawWithCtx", reflect.TypeOf((*MockDML)(nil).RawWithCtx), varargs...)
}

// Update mocks base method.
func (m *MockDML) Update(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockDMLMockRecorder) Update(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockDML)(nil).Update), varargs...)
}

// UpdateWithCtx mocks base method.
func (m *MockDML) UpdateWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx.
func (mr *MockDMLMockRecorder) UpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*MockDML)(nil).UpdateWithCtx), varargs...)
}

// MockDQL is a mock of DQL interface.
type MockDQL struct {
	ctrl     *gomock.Controller
	recorder *MockDQLMockRecorder
}

// MockDQLMockRecorder is the mock recorder for MockDQL.
type MockDQLMockRecorder struct {
	mock *MockDQL
}

// NewMockDQL creates a new mock instance.
func NewMockDQL(ctrl *gomock.Controller) *MockDQL {
	mock := &MockDQL{ctrl: ctrl}
	mock.recorder = &MockDQLMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDQL) EXPECT() *MockDQLMockRecorder {
	return m.recorder
}

// DBStats mocks base method.
func (m *MockDQL) DBStats() *sql.DBStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DBStats")
	ret0, _ := ret[0].(*sql.DBStats)
	return ret0
}

// DBStats indicates an expected call of DBStats.
func (mr *MockDQLMockRecorder) DBStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBStats", reflect.TypeOf((*MockDQL)(nil).DBStats))
}

// LoadRelated mocks base method.
func (m *MockDQL) LoadRelated(md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelated", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelated indicates an expected call of LoadRelated.
func (mr *MockDQLMockRecorder) LoadRelated(md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelated", reflect.TypeOf((*MockDQL)(nil).LoadRelated), varargs...)
}

// LoadRelatedWithCtx mocks base method.
func (m *MockDQL) LoadRelatedWithCtx(ctx context.Context, md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelatedWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelatedWithCtx indicates an expected call of LoadRelatedWithCtx.
func (mr *MockDQLMockRecorder) LoadRelatedWithCtx(ctx, md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelatedWithCtx", reflect.TypeOf((*MockDQL)(nil).LoadRelatedWithCtx), varargs...)
}

// QueryM2M mocks base method.
func (m *MockDQL) QueryM2M(md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2M", md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2M indicates an expected call of QueryM2M.
func (mr *MockDQLMockRecorder) QueryM2M(md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2M", reflect.TypeOf((*MockDQL)(nil).QueryM2M), md, name)
}

// QueryM2MWithCtx mocks base method.
func (m *MockDQL) QueryM2MWithCtx(ctx context.Context, md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2MWithCtx", ctx, md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2MWithCtx indicates an expected call of QueryM2MWithCtx.
func (mr *MockDQLMockRecorder) QueryM2MWithCtx(ctx, md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2MWithCtx", reflect.TypeOf((*MockDQL)(nil).QueryM2MWithCtx), ctx, md, name)
}

// QueryTable mocks base method.
func (m *MockDQL) QueryTable(ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTable", ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTable indicates an expected call of QueryTable.
func (mr *MockDQLMockRecorder) QueryTable(ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTable", reflect.TypeOf((*MockDQL)(nil).QueryTable), ptrStructOrTableName)
}

// QueryTableWithCtx mocks base method.
func (m *MockDQL) QueryTableWithCtx(ctx context.Context, ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTableWithCtx", ctx, ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTableWithCtx indicates an expected call of QueryTableWithCtx.
func (mr *MockDQLMockRecorder) QueryTableWithCtx(ctx, ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTableWithCtx", reflect.TypeOf((*MockDQL)(nil).QueryTableWithCtx), ctx, ptrStructOrTableName)
}

// Read mocks base method.
func (m *MockDQL) Read(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read.
func (mr *MockDQLMockRecorder) Read(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockDQL)(nil).Read), varargs...)
}

// ReadForUpdate mocks base method.
func (m *MockDQL) ReadForUpdate(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdate indicates an expected call of ReadForUpdate.
func (mr *MockDQLMockRecorder) ReadForUpdate(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdate", reflect.TypeOf((*MockDQL)(nil).ReadForUpdate), varargs...)
}

// ReadForUpdateWithCtx mocks base method.
func (m *MockDQL) ReadForUpdateWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdateWithCtx indicates an expected call of ReadForUpdateWithCtx.
func (mr *MockDQLMockRecorder) ReadForUpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdateWithCtx", reflect.TypeOf((*MockDQL)(nil).ReadForUpdateWithCtx), varargs...)
}

// ReadOrCreate mocks base method.
func (m *MockDQL) ReadOrCreate(md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreate indicates an expected call of ReadOrCreate.
func (mr *MockDQLMockRecorder) ReadOrCreate(md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreate", reflect.TypeOf((*MockDQL)(nil).ReadOrCreate), varargs...)
}

// ReadOrCreateWithCtx mocks base method.
func (m *MockDQL) ReadOrCreateWithCtx(ctx context.Context, md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreateWithCtx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreateWithCtx indicates an expected call of ReadOrCreateWithCtx.
func (mr *MockDQLMockRecorder) ReadOrCreateWithCtx(ctx, md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreateWithCtx", reflect.TypeOf((*MockDQL)(nil).ReadOrCreateWithCtx), varargs...)
}

// ReadRaw mocks base method.
func (m *MockDQL) ReadRaw(ctx context.Context, md interface{}, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadRaw", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadRaw indicates an expected call of ReadRaw.
func (mr *MockDQLMockRecorder) ReadRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadRaw", reflect.TypeOf((*MockDQL)(nil).ReadRaw), varargs...)
}

// ReadWithCtx mocks base method.
func (m *MockDQL) ReadWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadWithCtx indicates an expected call of ReadWithCtx.
func (mr *MockDQLMockRecorder) ReadWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWithCtx", reflect.TypeOf((*MockDQL)(nil).ReadWithCtx), varargs...)
}

// MockDriverGetter is a mock of DriverGetter interface.
type MockDriverGetter struct {
	ctrl     *gomock.Controller
	recorder *MockDriverGetterMockRecorder
}

// MockDriverGetterMockRecorder is the mock recorder for MockDriverGetter.
type MockDriverGetterMockRecorder struct {
	mock *MockDriverGetter
}

// NewMockDriverGetter creates a new mock instance.
func NewMockDriverGetter(ctrl *gomock.Controller) *MockDriverGetter {
	mock := &MockDriverGetter{ctrl: ctrl}
	mock.recorder = &MockDriverGetterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDriverGetter) EXPECT() *MockDriverGetterMockRecorder {
	return m.recorder
}

// Driver mocks base method.
func (m *MockDriverGetter) Driver() Driver {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(Driver)
	return ret0
}

// Driver indicates an expected call of Driver.
func (mr *MockDriverGetterMockRecorder) Driver() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockDriverGetter)(nil).Driver))
}

// Mockormer is a mock of ormer interface.
type Mockormer struct {
	ctrl     *gomock.Controller
	recorder *MockormerMockRecorder
}

// MockormerMockRecorder is the mock recorder for Mockormer.
type MockormerMockRecorder struct {
	mock *Mockormer
}

// NewMockormer creates a new mock instance.
func NewMockormer(ctrl *gomock.Controller) *Mockormer {
	mock := &Mockormer{ctrl: ctrl}
	mock.recorder = &MockormerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockormer) EXPECT() *MockormerMockRecorder {
	return m.recorder
}

// DBStats mocks base method.
func (m *Mockormer) DBStats() *sql.DBStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DBStats")
	ret0, _ := ret[0].(*sql.DBStats)
	return ret0
}

// DBStats indicates an expected call of DBStats.
func (mr *MockormerMockRecorder) DBStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBStats", reflect.TypeOf((*Mockormer)(nil).DBStats))
}

// Delete mocks base method.
func (m *Mockormer) Delete(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockormerMockRecorder) Delete(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*Mockormer)(nil).Delete), varargs...)
}

// DeleteWithCtx mocks base method.
func (m *Mockormer) DeleteWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx.
func (mr *MockormerMockRecorder) DeleteWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*Mockormer)(nil).DeleteWithCtx), varargs...)
}

// Driver mocks base method.
func (m *Mockormer) Driver() Driver {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(Driver)
	return ret0
}

// Driver indicates an expected call of Driver.
func (mr *MockormerMockRecorder) Driver() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*Mockormer)(nil).Driver))
}

// ExecRaw mocks base method.
func (m *Mockormer) ExecRaw(ctx context.Context, md interface{}, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecRaw", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecRaw indicates an expected call of ExecRaw.
func (mr *MockormerMockRecorder) ExecRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecRaw", reflect.TypeOf((*Mockormer)(nil).ExecRaw), varargs...)
}

// Insert mocks base method.
func (m *Mockormer) Insert(md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockormerMockRecorder) Insert(md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*Mockormer)(nil).Insert), md)
}

// InsertMulti mocks base method.
func (m *Mockormer) InsertMulti(bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMulti", bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti.
func (mr *MockormerMockRecorder) InsertMulti(bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*Mockormer)(nil).InsertMulti), bulk, mds)
}

// InsertMultiWithCtx mocks base method.
func (m *Mockormer) InsertMultiWithCtx(ctx context.Context, bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMultiWithCtx", ctx, bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMultiWithCtx indicates an expected call of InsertMultiWithCtx.
func (mr *MockormerMockRecorder) InsertMultiWithCtx(ctx, bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMultiWithCtx", reflect.TypeOf((*Mockormer)(nil).InsertMultiWithCtx), ctx, bulk, mds)
}

// InsertOrUpdate mocks base method.
func (m *Mockormer) InsertOrUpdate(md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate.
func (mr *MockormerMockRecorder) InsertOrUpdate(md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*Mockormer)(nil).InsertOrUpdate), varargs...)
}

// InsertOrUpdateWithCtx mocks base method.
func (m *Mockormer) InsertOrUpdateWithCtx(ctx context.Context, md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdateWithCtx indicates an expected call of InsertOrUpdateWithCtx.
func (mr *MockormerMockRecorder) InsertOrUpdateWithCtx(ctx, md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateWithCtx", reflect.TypeOf((*Mockormer)(nil).InsertOrUpdateWithCtx), varargs...)
}

// InsertWithCtx mocks base method.
func (m *Mockormer) InsertWithCtx(ctx context.Context, md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertWithCtx", ctx, md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx.
func (mr *MockormerMockRecorder) InsertWithCtx(ctx, md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*Mockormer)(nil).InsertWithCtx), ctx, md)
}

// LoadRelated mocks base method.
func (m *Mockormer) LoadRelated(md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelated", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelated indicates an expected call of LoadRelated.
func (mr *MockormerMockRecorder) LoadRelated(md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelated", reflect.TypeOf((*Mockormer)(nil).LoadRelated), varargs...)
}

// LoadRelatedWithCtx mocks base method.
func (m *Mockormer) LoadRelatedWithCtx(ctx context.Context, md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelatedWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelatedWithCtx indicates an expected call of LoadRelatedWithCtx.
func (mr *MockormerMockRecorder) LoadRelatedWithCtx(ctx, md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelatedWithCtx", reflect.TypeOf((*Mockormer)(nil).LoadRelatedWithCtx), varargs...)
}

// QueryM2M mocks base method.
func (m *Mockormer) QueryM2M(md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2M", md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2M indicates an expected call of QueryM2M.
func (mr *MockormerMockRecorder) QueryM2M(md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2M", reflect.TypeOf((*Mockormer)(nil).QueryM2M), md, name)
}

// QueryM2MWithCtx mocks base method.
func (m *Mockormer) QueryM2MWithCtx(ctx context.Context, md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2MWithCtx", ctx, md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2MWithCtx indicates an expected call of QueryM2MWithCtx.
func (mr *MockormerMockRecorder) QueryM2MWithCtx(ctx, md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2MWithCtx", reflect.TypeOf((*Mockormer)(nil).QueryM2MWithCtx), ctx, md, name)
}

// QueryTable mocks base method.
func (m *Mockormer) QueryTable(ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTable", ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTable indicates an expected call of QueryTable.
func (mr *MockormerMockRecorder) QueryTable(ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTable", reflect.TypeOf((*Mockormer)(nil).QueryTable), ptrStructOrTableName)
}

// QueryTableWithCtx mocks base method.
func (m *Mockormer) QueryTableWithCtx(ctx context.Context, ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTableWithCtx", ctx, ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTableWithCtx indicates an expected call of QueryTableWithCtx.
func (mr *MockormerMockRecorder) QueryTableWithCtx(ctx, ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTableWithCtx", reflect.TypeOf((*Mockormer)(nil).QueryTableWithCtx), ctx, ptrStructOrTableName)
}

// Raw mocks base method.
func (m *Mockormer) Raw(query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Raw", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// Raw indicates an expected call of Raw.
func (mr *MockormerMockRecorder) Raw(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Raw", reflect.TypeOf((*Mockormer)(nil).Raw), varargs...)
}

// RawWithCtx mocks base method.
func (m *Mockormer) RawWithCtx(ctx context.Context, query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RawWithCtx", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// RawWithCtx indicates an expected call of RawWithCtx.
func (mr *MockormerMockRecorder) RawWithCtx(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawWithCtx", reflect.TypeOf((*Mockormer)(nil).RawWithCtx), varargs...)
}

// Read mocks base method.
func (m *Mockormer) Read(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read.
func (mr *MockormerMockRecorder) Read(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*Mockormer)(nil).Read), varargs...)
}

// ReadForUpdate mocks base method.
func (m *Mockormer) ReadForUpdate(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdate indicates an expected call of ReadForUpdate.
func (mr *MockormerMockRecorder) ReadForUpdate(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdate", reflect.TypeOf((*Mockormer)(nil).ReadForUpdate), varargs...)
}

// ReadForUpdateWithCtx mocks base method.
func (m *Mockormer) ReadForUpdateWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdateWithCtx indicates an expected call of ReadForUpdateWithCtx.
func (mr *MockormerMockRecorder) ReadForUpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdateWithCtx", reflect.TypeOf((*Mockormer)(nil).ReadForUpdateWithCtx), varargs...)
}

// ReadOrCreate mocks base method.
func (m *Mockormer) ReadOrCreate(md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreate indicates an expected call of ReadOrCreate.
func (mr *MockormerMockRecorder) ReadOrCreate(md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreate", reflect.TypeOf((*Mockormer)(nil).ReadOrCreate), varargs...)
}

// ReadOrCreateWithCtx mocks base method.
func (m *Mockormer) ReadOrCreateWithCtx(ctx context.Context, md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreateWithCtx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreateWithCtx indicates an expected call of ReadOrCreateWithCtx.
func (mr *MockormerMockRecorder) ReadOrCreateWithCtx(ctx, md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreateWithCtx", reflect.TypeOf((*Mockormer)(nil).ReadOrCreateWithCtx), varargs...)
}

// ReadRaw mocks base method.
func (m *Mockormer) ReadRaw(ctx context.Context, md interface{}, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadRaw", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadRaw indicates an expected call of ReadRaw.
func (mr *MockormerMockRecorder) ReadRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadRaw", reflect.TypeOf((*Mockormer)(nil).ReadRaw), varargs...)
}

// ReadWithCtx mocks base method.
func (m *Mockormer) ReadWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadWithCtx indicates an expected call of ReadWithCtx.
func (mr *MockormerMockRecorder) ReadWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWithCtx", reflect.TypeOf((*Mockormer)(nil).ReadWithCtx), varargs...)
}

// Update mocks base method.
func (m *Mockormer) Update(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockormerMockRecorder) Update(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*Mockormer)(nil).Update), varargs...)
}

// UpdateWithCtx mocks base method.
func (m *Mockormer) UpdateWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx.
func (mr *MockormerMockRecorder) UpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*Mockormer)(nil).UpdateWithCtx), varargs...)
}

// MockQueryExecutor is a mock of QueryExecutor interface.
type MockQueryExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockQueryExecutorMockRecorder
}

// MockQueryExecutorMockRecorder is the mock recorder for MockQueryExecutor.
type MockQueryExecutorMockRecorder struct {
	mock *MockQueryExecutor
}

// NewMockQueryExecutor creates a new mock instance.
func NewMockQueryExecutor(ctrl *gomock.Controller) *MockQueryExecutor {
	mock := &MockQueryExecutor{ctrl: ctrl}
	mock.recorder = &MockQueryExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryExecutor) EXPECT() *MockQueryExecutorMockRecorder {
	return m.recorder
}

// DBStats mocks base method.
func (m *MockQueryExecutor) DBStats() *sql.DBStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DBStats")
	ret0, _ := ret[0].(*sql.DBStats)
	return ret0
}

// DBStats indicates an expected call of DBStats.
func (mr *MockQueryExecutorMockRecorder) DBStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBStats", reflect.TypeOf((*MockQueryExecutor)(nil).DBStats))
}

// Delete mocks base method.
func (m *MockQueryExecutor) Delete(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockQueryExecutorMockRecorder) Delete(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockQueryExecutor)(nil).Delete), varargs...)
}

// DeleteWithCtx mocks base method.
func (m *MockQueryExecutor) DeleteWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx.
func (mr *MockQueryExecutorMockRecorder) DeleteWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).DeleteWithCtx), varargs...)
}

// Driver mocks base method.
func (m *MockQueryExecutor) Driver() Driver {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(Driver)
	return ret0
}

// Driver indicates an expected call of Driver.
func (mr *MockQueryExecutorMockRecorder) Driver() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockQueryExecutor)(nil).Driver))
}

// ExecRaw mocks base method.
func (m *MockQueryExecutor) ExecRaw(ctx context.Context, md interface{}, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecRaw", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecRaw indicates an expected call of ExecRaw.
func (mr *MockQueryExecutorMockRecorder) ExecRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecRaw", reflect.TypeOf((*MockQueryExecutor)(nil).ExecRaw), varargs...)
}

// Insert mocks base method.
func (m *MockQueryExecutor) Insert(md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockQueryExecutorMockRecorder) Insert(md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockQueryExecutor)(nil).Insert), md)
}

// InsertMulti mocks base method.
func (m *MockQueryExecutor) InsertMulti(bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMulti", bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti.
func (mr *MockQueryExecutorMockRecorder) InsertMulti(bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*MockQueryExecutor)(nil).InsertMulti), bulk, mds)
}

// InsertMultiWithCtx mocks base method.
func (m *MockQueryExecutor) InsertMultiWithCtx(ctx context.Context, bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMultiWithCtx", ctx, bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMultiWithCtx indicates an expected call of InsertMultiWithCtx.
func (mr *MockQueryExecutorMockRecorder) InsertMultiWithCtx(ctx, bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMultiWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).InsertMultiWithCtx), ctx, bulk, mds)
}

// InsertOrUpdate mocks base method.
func (m *MockQueryExecutor) InsertOrUpdate(md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate.
func (mr *MockQueryExecutorMockRecorder) InsertOrUpdate(md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*MockQueryExecutor)(nil).InsertOrUpdate), varargs...)
}

// InsertOrUpdateWithCtx mocks base method.
func (m *MockQueryExecutor) InsertOrUpdateWithCtx(ctx context.Context, md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdateWithCtx indicates an expected call of InsertOrUpdateWithCtx.
func (mr *MockQueryExecutorMockRecorder) InsertOrUpdateWithCtx(ctx, md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).InsertOrUpdateWithCtx), varargs...)
}

// InsertWithCtx mocks base method.
func (m *MockQueryExecutor) InsertWithCtx(ctx context.Context, md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertWithCtx", ctx, md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx.
func (mr *MockQueryExecutorMockRecorder) InsertWithCtx(ctx, md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).InsertWithCtx), ctx, md)
}

// LoadRelated mocks base method.
func (m *MockQueryExecutor) LoadRelated(md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelated", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelated indicates an expected call of LoadRelated.
func (mr *MockQueryExecutorMockRecorder) LoadRelated(md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelated", reflect.TypeOf((*MockQueryExecutor)(nil).LoadRelated), varargs...)
}

// LoadRelatedWithCtx mocks base method.
func (m *MockQueryExecutor) LoadRelatedWithCtx(ctx context.Context, md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelatedWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelatedWithCtx indicates an expected call of LoadRelatedWithCtx.
func (mr *MockQueryExecutorMockRecorder) LoadRelatedWithCtx(ctx, md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelatedWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).LoadRelatedWithCtx), varargs...)
}

// QueryM2M mocks base method.
func (m *MockQueryExecutor) QueryM2M(md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2M", md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2M indicates an expected call of QueryM2M.
func (mr *MockQueryExecutorMockRecorder) QueryM2M(md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2M", reflect.TypeOf((*MockQueryExecutor)(nil).QueryM2M), md, name)
}

// QueryM2MWithCtx mocks base method.
func (m *MockQueryExecutor) QueryM2MWithCtx(ctx context.Context, md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2MWithCtx", ctx, md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2MWithCtx indicates an expected call of QueryM2MWithCtx.
func (mr *MockQueryExecutorMockRecorder) QueryM2MWithCtx(ctx, md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2MWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).QueryM2MWithCtx), ctx, md, name)
}

// QueryTable mocks base method.
func (m *MockQueryExecutor) QueryTable(ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTable", ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTable indicates an expected call of QueryTable.
func (mr *MockQueryExecutorMockRecorder) QueryTable(ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTable", reflect.TypeOf((*MockQueryExecutor)(nil).QueryTable), ptrStructOrTableName)
}

// QueryTableWithCtx mocks base method.
func (m *MockQueryExecutor) QueryTableWithCtx(ctx context.Context, ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTableWithCtx", ctx, ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTableWithCtx indicates an expected call of QueryTableWithCtx.
func (mr *MockQueryExecutorMockRecorder) QueryTableWithCtx(ctx, ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTableWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).QueryTableWithCtx), ctx, ptrStructOrTableName)
}

// Raw mocks base method.
func (m *MockQueryExecutor) Raw(query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Raw", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// Raw indicates an expected call of Raw.
func (mr *MockQueryExecutorMockRecorder) Raw(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Raw", reflect.TypeOf((*MockQueryExecutor)(nil).Raw), varargs...)
}

// RawWithCtx mocks base method.
func (m *MockQueryExecutor) RawWithCtx(ctx context.Context, query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RawWithCtx", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// RawWithCtx indicates an expected call of RawWithCtx.
func (mr *MockQueryExecutorMockRecorder) RawWithCtx(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).RawWithCtx), varargs...)
}

// Read mocks base method.
func (m *MockQueryExecutor) Read(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read.
func (mr *MockQueryExecutorMockRecorder) Read(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockQueryExecutor)(nil).Read), varargs...)
}

// ReadForUpdate mocks base method.
func (m *MockQueryExecutor) ReadForUpdate(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdate indicates an expected call of ReadForUpdate.
func (mr *MockQueryExecutorMockRecorder) ReadForUpdate(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdate", reflect.TypeOf((*MockQueryExecutor)(nil).ReadForUpdate), varargs...)
}

// ReadForUpdateWithCtx mocks base method.
func (m *MockQueryExecutor) ReadForUpdateWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdateWithCtx indicates an expected call of ReadForUpdateWithCtx.
func (mr *MockQueryExecutorMockRecorder) ReadForUpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdateWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).ReadForUpdateWithCtx), varargs...)
}

// ReadOrCreate mocks base method.
func (m *MockQueryExecutor) ReadOrCreate(md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreate indicates an expected call of ReadOrCreate.
func (mr *MockQueryExecutorMockRecorder) ReadOrCreate(md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreate", reflect.TypeOf((*MockQueryExecutor)(nil).ReadOrCreate), varargs...)
}

// ReadOrCreateWithCtx mocks base method.
func (m *MockQueryExecutor) ReadOrCreateWithCtx(ctx context.Context, md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreateWithCtx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreateWithCtx indicates an expected call of ReadOrCreateWithCtx.
func (mr *MockQueryExecutorMockRecorder) ReadOrCreateWithCtx(ctx, md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreateWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).ReadOrCreateWithCtx), varargs...)
}

// ReadRaw mocks base method.
func (m *MockQueryExecutor) ReadRaw(ctx context.Context, md interface{}, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadRaw", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadRaw indicates an expected call of ReadRaw.
func (mr *MockQueryExecutorMockRecorder) ReadRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadRaw", reflect.TypeOf((*MockQueryExecutor)(nil).ReadRaw), varargs...)
}

// ReadWithCtx mocks base method.
func (m *MockQueryExecutor) ReadWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadWithCtx indicates an expected call of ReadWithCtx.
func (mr *MockQueryExecutorMockRecorder) ReadWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).ReadWithCtx), varargs...)
}

// Update mocks base method.
func (m *MockQueryExecutor) Update(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockQueryExecutorMockRecorder) Update(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockQueryExecutor)(nil).Update), varargs...)
}

// UpdateWithCtx mocks base method.
func (m *MockQueryExecutor) UpdateWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx.
func (mr *MockQueryExecutorMockRecorder) UpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*MockQueryExecutor)(nil).UpdateWithCtx), varargs...)
}

// MockOrmer is a mock of Ormer interface.
type MockOrmer struct {
	ctrl     *gomock.Controller
	recorder *MockOrmerMockRecorder
}

// MockOrmerMockRecorder is the mock recorder for MockOrmer.
type MockOrmerMockRecorder struct {
	mock *MockOrmer
}

// NewMockOrmer creates a new mock instance.
func NewMockOrmer(ctrl *gomock.Controller) *MockOrmer {
	mock := &MockOrmer{ctrl: ctrl}
	mock.recorder = &MockOrmerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrmer) EXPECT() *MockOrmerMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockOrmer) Begin() (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockOrmerMockRecorder) Begin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockOrmer)(nil).Begin))
}

// BeginWithCtx mocks base method.
func (m *MockOrmer) BeginWithCtx(ctx context.Context) (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginWithCtx", ctx)
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithCtx indicates an expected call of BeginWithCtx.
func (mr *MockOrmerMockRecorder) BeginWithCtx(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithCtx", reflect.TypeOf((*MockOrmer)(nil).BeginWithCtx), ctx)
}

// BeginWithCtxAndOpts mocks base method.
func (m *MockOrmer) BeginWithCtxAndOpts(ctx context.Context, opts *sql.TxOptions) (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginWithCtxAndOpts", ctx, opts)
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithCtxAndOpts indicates an expected call of BeginWithCtxAndOpts.
func (mr *MockOrmerMockRecorder) BeginWithCtxAndOpts(ctx, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithCtxAndOpts", reflect.TypeOf((*MockOrmer)(nil).BeginWithCtxAndOpts), ctx, opts)
}

// BeginWithOpts mocks base method.
func (m *MockOrmer) BeginWithOpts(opts *sql.TxOptions) (TxOrmer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginWithOpts", opts)
	ret0, _ := ret[0].(TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithOpts indicates an expected call of BeginWithOpts.
func (mr *MockOrmerMockRecorder) BeginWithOpts(opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithOpts", reflect.TypeOf((*MockOrmer)(nil).BeginWithOpts), opts)
}

// DBStats mocks base method.
func (m *MockOrmer) DBStats() *sql.DBStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DBStats")
	ret0, _ := ret[0].(*sql.DBStats)
	return ret0
}

// DBStats indicates an expected call of DBStats.
func (mr *MockOrmerMockRecorder) DBStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBStats", reflect.TypeOf((*MockOrmer)(nil).DBStats))
}

// Delete mocks base method.
func (m *MockOrmer) Delete(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockOrmerMockRecorder) Delete(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockOrmer)(nil).Delete), varargs...)
}

// DeleteWithCtx mocks base method.
func (m *MockOrmer) DeleteWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx.
func (mr *MockOrmerMockRecorder) DeleteWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*MockOrmer)(nil).DeleteWithCtx), varargs...)
}

// DoTx mocks base method.
func (m *MockOrmer) DoTx(task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTx", task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTx indicates an expected call of DoTx.
func (mr *MockOrmerMockRecorder) DoTx(task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTx", reflect.TypeOf((*MockOrmer)(nil).DoTx), task)
}

// DoTxWithCtx mocks base method.
func (m *MockOrmer) DoTxWithCtx(ctx context.Context, task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxWithCtx", ctx, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithCtx indicates an expected call of DoTxWithCtx.
func (mr *MockOrmerMockRecorder) DoTxWithCtx(ctx, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithCtx", reflect.TypeOf((*MockOrmer)(nil).DoTxWithCtx), ctx, task)
}

// DoTxWithCtxAndOpts mocks base method.
func (m *MockOrmer) DoTxWithCtxAndOpts(ctx context.Context, opts *sql.TxOptions, task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxWithCtxAndOpts", ctx, opts, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithCtxAndOpts indicates an expected call of DoTxWithCtxAndOpts.
func (mr *MockOrmerMockRecorder) DoTxWithCtxAndOpts(ctx, opts, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithCtxAndOpts", reflect.TypeOf((*MockOrmer)(nil).DoTxWithCtxAndOpts), ctx, opts, task)
}

// DoTxWithOpts mocks base method.
func (m *MockOrmer) DoTxWithOpts(opts *sql.TxOptions, task func(context.Context, TxOrmer) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxWithOpts", opts, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithOpts indicates an expected call of DoTxWithOpts.
func (mr *MockOrmerMockRecorder) DoTxWithOpts(opts, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithOpts", reflect.TypeOf((*MockOrmer)(nil).DoTxWithOpts), opts, task)
}

// Driver mocks base method.
func (m *MockOrmer) Driver() Driver {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(Driver)
	return ret0
}

// Driver indicates an expected call of Driver.
func (mr *MockOrmerMockRecorder) Driver() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockOrmer)(nil).Driver))
}

// ExecRaw mocks base method.
func (m *MockOrmer) ExecRaw(ctx context.Context, md interface{}, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecRaw", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecRaw indicates an expected call of ExecRaw.
func (mr *MockOrmerMockRecorder) ExecRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecRaw", reflect.TypeOf((*MockOrmer)(nil).ExecRaw), varargs...)
}

// Insert mocks base method.
func (m *MockOrmer) Insert(md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockOrmerMockRecorder) Insert(md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockOrmer)(nil).Insert), md)
}

// InsertMulti mocks base method.
func (m *MockOrmer) InsertMulti(bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMulti", bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti.
func (mr *MockOrmerMockRecorder) InsertMulti(bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*MockOrmer)(nil).InsertMulti), bulk, mds)
}

// InsertMultiWithCtx mocks base method.
func (m *MockOrmer) InsertMultiWithCtx(ctx context.Context, bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMultiWithCtx", ctx, bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMultiWithCtx indicates an expected call of InsertMultiWithCtx.
func (mr *MockOrmerMockRecorder) InsertMultiWithCtx(ctx, bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMultiWithCtx", reflect.TypeOf((*MockOrmer)(nil).InsertMultiWithCtx), ctx, bulk, mds)
}

// InsertOrUpdate mocks base method.
func (m *MockOrmer) InsertOrUpdate(md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate.
func (mr *MockOrmerMockRecorder) InsertOrUpdate(md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*MockOrmer)(nil).InsertOrUpdate), varargs...)
}

// InsertOrUpdateWithCtx mocks base method.
func (m *MockOrmer) InsertOrUpdateWithCtx(ctx context.Context, md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdateWithCtx indicates an expected call of InsertOrUpdateWithCtx.
func (mr *MockOrmerMockRecorder) InsertOrUpdateWithCtx(ctx, md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateWithCtx", reflect.TypeOf((*MockOrmer)(nil).InsertOrUpdateWithCtx), varargs...)
}

// InsertWithCtx mocks base method.
func (m *MockOrmer) InsertWithCtx(ctx context.Context, md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertWithCtx", ctx, md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx.
func (mr *MockOrmerMockRecorder) InsertWithCtx(ctx, md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*MockOrmer)(nil).InsertWithCtx), ctx, md)
}

// LoadRelated mocks base method.
func (m *MockOrmer) LoadRelated(md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelated", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelated indicates an expected call of LoadRelated.
func (mr *MockOrmerMockRecorder) LoadRelated(md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelated", reflect.TypeOf((*MockOrmer)(nil).LoadRelated), varargs...)
}

// LoadRelatedWithCtx mocks base method.
func (m *MockOrmer) LoadRelatedWithCtx(ctx context.Context, md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelatedWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelatedWithCtx indicates an expected call of LoadRelatedWithCtx.
func (mr *MockOrmerMockRecorder) LoadRelatedWithCtx(ctx, md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelatedWithCtx", reflect.TypeOf((*MockOrmer)(nil).LoadRelatedWithCtx), varargs...)
}

// QueryM2M mocks base method.
func (m *MockOrmer) QueryM2M(md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2M", md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2M indicates an expected call of QueryM2M.
func (mr *MockOrmerMockRecorder) QueryM2M(md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2M", reflect.TypeOf((*MockOrmer)(nil).QueryM2M), md, name)
}

// QueryM2MWithCtx mocks base method.
func (m *MockOrmer) QueryM2MWithCtx(ctx context.Context, md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2MWithCtx", ctx, md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2MWithCtx indicates an expected call of QueryM2MWithCtx.
func (mr *MockOrmerMockRecorder) QueryM2MWithCtx(ctx, md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2MWithCtx", reflect.TypeOf((*MockOrmer)(nil).QueryM2MWithCtx), ctx, md, name)
}

// QueryTable mocks base method.
func (m *MockOrmer) QueryTable(ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTable", ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTable indicates an expected call of QueryTable.
func (mr *MockOrmerMockRecorder) QueryTable(ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTable", reflect.TypeOf((*MockOrmer)(nil).QueryTable), ptrStructOrTableName)
}

// QueryTableWithCtx mocks base method.
func (m *MockOrmer) QueryTableWithCtx(ctx context.Context, ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTableWithCtx", ctx, ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTableWithCtx indicates an expected call of QueryTableWithCtx.
func (mr *MockOrmerMockRecorder) QueryTableWithCtx(ctx, ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTableWithCtx", reflect.TypeOf((*MockOrmer)(nil).QueryTableWithCtx), ctx, ptrStructOrTableName)
}

// Raw mocks base method.
func (m *MockOrmer) Raw(query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Raw", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// Raw indicates an expected call of Raw.
func (mr *MockOrmerMockRecorder) Raw(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Raw", reflect.TypeOf((*MockOrmer)(nil).Raw), varargs...)
}

// RawWithCtx mocks base method.
func (m *MockOrmer) RawWithCtx(ctx context.Context, query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RawWithCtx", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// RawWithCtx indicates an expected call of RawWithCtx.
func (mr *MockOrmerMockRecorder) RawWithCtx(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawWithCtx", reflect.TypeOf((*MockOrmer)(nil).RawWithCtx), varargs...)
}

// Read mocks base method.
func (m *MockOrmer) Read(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read.
func (mr *MockOrmerMockRecorder) Read(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockOrmer)(nil).Read), varargs...)
}

// ReadForUpdate mocks base method.
func (m *MockOrmer) ReadForUpdate(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdate indicates an expected call of ReadForUpdate.
func (mr *MockOrmerMockRecorder) ReadForUpdate(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdate", reflect.TypeOf((*MockOrmer)(nil).ReadForUpdate), varargs...)
}

// ReadForUpdateWithCtx mocks base method.
func (m *MockOrmer) ReadForUpdateWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdateWithCtx indicates an expected call of ReadForUpdateWithCtx.
func (mr *MockOrmerMockRecorder) ReadForUpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdateWithCtx", reflect.TypeOf((*MockOrmer)(nil).ReadForUpdateWithCtx), varargs...)
}

// ReadOrCreate mocks base method.
func (m *MockOrmer) ReadOrCreate(md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreate indicates an expected call of ReadOrCreate.
func (mr *MockOrmerMockRecorder) ReadOrCreate(md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreate", reflect.TypeOf((*MockOrmer)(nil).ReadOrCreate), varargs...)
}

// ReadOrCreateWithCtx mocks base method.
func (m *MockOrmer) ReadOrCreateWithCtx(ctx context.Context, md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreateWithCtx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreateWithCtx indicates an expected call of ReadOrCreateWithCtx.
func (mr *MockOrmerMockRecorder) ReadOrCreateWithCtx(ctx, md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreateWithCtx", reflect.TypeOf((*MockOrmer)(nil).ReadOrCreateWithCtx), varargs...)
}

// ReadRaw mocks base method.
func (m *MockOrmer) ReadRaw(ctx context.Context, md interface{}, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadRaw", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadRaw indicates an expected call of ReadRaw.
func (mr *MockOrmerMockRecorder) ReadRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadRaw", reflect.TypeOf((*MockOrmer)(nil).ReadRaw), varargs...)
}

// ReadWithCtx mocks base method.
func (m *MockOrmer) ReadWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadWithCtx indicates an expected call of ReadWithCtx.
func (mr *MockOrmerMockRecorder) ReadWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWithCtx", reflect.TypeOf((*MockOrmer)(nil).ReadWithCtx), varargs...)
}

// Update mocks base method.
func (m *MockOrmer) Update(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockOrmerMockRecorder) Update(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrmer)(nil).Update), varargs...)
}

// UpdateWithCtx mocks base method.
func (m *MockOrmer) UpdateWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx.
func (mr *MockOrmerMockRecorder) UpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*MockOrmer)(nil).UpdateWithCtx), varargs...)
}

// MockTxOrmer is a mock of TxOrmer interface.
type MockTxOrmer struct {
	ctrl     *gomock.Controller
	recorder *MockTxOrmerMockRecorder
}

// MockTxOrmerMockRecorder is the mock recorder for MockTxOrmer.
type MockTxOrmerMockRecorder struct {
	mock *MockTxOrmer
}

// NewMockTxOrmer creates a new mock instance.
func NewMockTxOrmer(ctrl *gomock.Controller) *MockTxOrmer {
	mock := &MockTxOrmer{ctrl: ctrl}
	mock.recorder = &MockTxOrmerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxOrmer) EXPECT() *MockTxOrmerMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockTxOrmer) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTxOrmerMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTxOrmer)(nil).Commit))
}

// DBStats mocks base method.
func (m *MockTxOrmer) DBStats() *sql.DBStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DBStats")
	ret0, _ := ret[0].(*sql.DBStats)
	return ret0
}

// DBStats indicates an expected call of DBStats.
func (mr *MockTxOrmerMockRecorder) DBStats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBStats", reflect.TypeOf((*MockTxOrmer)(nil).DBStats))
}

// Delete mocks base method.
func (m *MockTxOrmer) Delete(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockTxOrmerMockRecorder) Delete(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTxOrmer)(nil).Delete), varargs...)
}

// DeleteWithCtx mocks base method.
func (m *MockTxOrmer) DeleteWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx.
func (mr *MockTxOrmerMockRecorder) DeleteWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).DeleteWithCtx), varargs...)
}

// Driver mocks base method.
func (m *MockTxOrmer) Driver() Driver {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(Driver)
	return ret0
}

// Driver indicates an expected call of Driver.
func (mr *MockTxOrmerMockRecorder) Driver() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockTxOrmer)(nil).Driver))
}

// ExecRaw mocks base method.
func (m *MockTxOrmer) ExecRaw(ctx context.Context, md interface{}, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecRaw", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecRaw indicates an expected call of ExecRaw.
func (mr *MockTxOrmerMockRecorder) ExecRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecRaw", reflect.TypeOf((*MockTxOrmer)(nil).ExecRaw), varargs...)
}

// Insert mocks base method.
func (m *MockTxOrmer) Insert(md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockTxOrmerMockRecorder) Insert(md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockTxOrmer)(nil).Insert), md)
}

// InsertMulti mocks base method.
func (m *MockTxOrmer) InsertMulti(bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMulti", bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti.
func (mr *MockTxOrmerMockRecorder) InsertMulti(bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*MockTxOrmer)(nil).InsertMulti), bulk, mds)
}

// InsertMultiWithCtx mocks base method.
func (m *MockTxOrmer) InsertMultiWithCtx(ctx context.Context, bulk int, mds interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMultiWithCtx", ctx, bulk, mds)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMultiWithCtx indicates an expected call of InsertMultiWithCtx.
func (mr *MockTxOrmerMockRecorder) InsertMultiWithCtx(ctx, bulk, mds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMultiWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).InsertMultiWithCtx), ctx, bulk, mds)
}

// InsertOrUpdate mocks base method.
func (m *MockTxOrmer) InsertOrUpdate(md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate.
func (mr *MockTxOrmerMockRecorder) InsertOrUpdate(md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*MockTxOrmer)(nil).InsertOrUpdate), varargs...)
}

// InsertOrUpdateWithCtx mocks base method.
func (m *MockTxOrmer) InsertOrUpdateWithCtx(ctx context.Context, md interface{}, colConflitAndArgs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range colConflitAndArgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdateWithCtx indicates an expected call of InsertOrUpdateWithCtx.
func (mr *MockTxOrmerMockRecorder) InsertOrUpdateWithCtx(ctx, md interface{}, colConflitAndArgs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, colConflitAndArgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).InsertOrUpdateWithCtx), varargs...)
}

// InsertWithCtx mocks base method.
func (m *MockTxOrmer) InsertWithCtx(ctx context.Context, md interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertWithCtx", ctx, md)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx.
func (mr *MockTxOrmerMockRecorder) InsertWithCtx(ctx, md interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).InsertWithCtx), ctx, md)
}

// LoadRelated mocks base method.
func (m *MockTxOrmer) LoadRelated(md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelated", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelated indicates an expected call of LoadRelated.
func (mr *MockTxOrmerMockRecorder) LoadRelated(md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelated", reflect.TypeOf((*MockTxOrmer)(nil).LoadRelated), varargs...)
}

// LoadRelatedWithCtx mocks base method.
func (m *MockTxOrmer) LoadRelatedWithCtx(ctx context.Context, md interface{}, name string, args ...utils.KV) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelatedWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelatedWithCtx indicates an expected call of LoadRelatedWithCtx.
func (mr *MockTxOrmerMockRecorder) LoadRelatedWithCtx(ctx, md, name interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelatedWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).LoadRelatedWithCtx), varargs...)
}

// QueryM2M mocks base method.
func (m *MockTxOrmer) QueryM2M(md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2M", md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2M indicates an expected call of QueryM2M.
func (mr *MockTxOrmerMockRecorder) QueryM2M(md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2M", reflect.TypeOf((*MockTxOrmer)(nil).QueryM2M), md, name)
}

// QueryM2MWithCtx mocks base method.
func (m *MockTxOrmer) QueryM2MWithCtx(ctx context.Context, md interface{}, name string) QueryM2Mer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryM2MWithCtx", ctx, md, name)
	ret0, _ := ret[0].(QueryM2Mer)
	return ret0
}

// QueryM2MWithCtx indicates an expected call of QueryM2MWithCtx.
func (mr *MockTxOrmerMockRecorder) QueryM2MWithCtx(ctx, md, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2MWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).QueryM2MWithCtx), ctx, md, name)
}

// QueryTable mocks base method.
func (m *MockTxOrmer) QueryTable(ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTable", ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTable indicates an expected call of QueryTable.
func (mr *MockTxOrmerMockRecorder) QueryTable(ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTable", reflect.TypeOf((*MockTxOrmer)(nil).QueryTable), ptrStructOrTableName)
}

// QueryTableWithCtx mocks base method.
func (m *MockTxOrmer) QueryTableWithCtx(ctx context.Context, ptrStructOrTableName interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryTableWithCtx", ctx, ptrStructOrTableName)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// QueryTableWithCtx indicates an expected call of QueryTableWithCtx.
func (mr *MockTxOrmerMockRecorder) QueryTableWithCtx(ctx, ptrStructOrTableName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTableWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).QueryTableWithCtx), ctx, ptrStructOrTableName)
}

// Raw mocks base method.
func (m *MockTxOrmer) Raw(query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Raw", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// Raw indicates an expected call of Raw.
func (mr *MockTxOrmerMockRecorder) Raw(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Raw", reflect.TypeOf((*MockTxOrmer)(nil).Raw), varargs...)
}

// RawWithCtx mocks base method.
func (m *MockTxOrmer) RawWithCtx(ctx context.Context, query string, args ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RawWithCtx", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// RawWithCtx indicates an expected call of RawWithCtx.
func (mr *MockTxOrmerMockRecorder) RawWithCtx(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).RawWithCtx), varargs...)
}

// Read mocks base method.
func (m *MockTxOrmer) Read(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read.
func (mr *MockTxOrmerMockRecorder) Read(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockTxOrmer)(nil).Read), varargs...)
}

// ReadForUpdate mocks base method.
func (m *MockTxOrmer) ReadForUpdate(md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdate indicates an expected call of ReadForUpdate.
func (mr *MockTxOrmerMockRecorder) ReadForUpdate(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdate", reflect.TypeOf((*MockTxOrmer)(nil).ReadForUpdate), varargs...)
}

// ReadForUpdateWithCtx mocks base method.
func (m *MockTxOrmer) ReadForUpdateWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdateWithCtx indicates an expected call of ReadForUpdateWithCtx.
func (mr *MockTxOrmerMockRecorder) ReadForUpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdateWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).ReadForUpdateWithCtx), varargs...)
}

// ReadOrCreate mocks base method.
func (m *MockTxOrmer) ReadOrCreate(md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreate indicates an expected call of ReadOrCreate.
func (mr *MockTxOrmerMockRecorder) ReadOrCreate(md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreate", reflect.TypeOf((*MockTxOrmer)(nil).ReadOrCreate), varargs...)
}

// ReadOrCreateWithCtx mocks base method.
func (m *MockTxOrmer) ReadOrCreateWithCtx(ctx context.Context, md interface{}, col1 string, cols ...string) (bool, int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, col1}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreateWithCtx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreateWithCtx indicates an expected call of ReadOrCreateWithCtx.
func (mr *MockTxOrmerMockRecorder) ReadOrCreateWithCtx(ctx, md, col1 interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, col1}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreateWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).ReadOrCreateWithCtx), varargs...)
}

// ReadRaw mocks base method.
func (m *MockTxOrmer) ReadRaw(ctx context.Context, md interface{}, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadRaw", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadRaw indicates an expected call of ReadRaw.
func (mr *MockTxOrmerMockRecorder) ReadRaw(ctx, md, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadRaw", reflect.TypeOf((*MockTxOrmer)(nil).ReadRaw), varargs...)
}

// ReadWithCtx mocks base method.
func (m *MockTxOrmer) ReadWithCtx(ctx context.Context, md interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadWithCtx indicates an expected call of ReadWithCtx.
func (mr *MockTxOrmerMockRecorder) ReadWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).ReadWithCtx), varargs...)
}

// Rollback mocks base method.
func (m *MockTxOrmer) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTxOrmerMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTxOrmer)(nil).Rollback))
}

// RollbackUnlessCommit mocks base method.
func (m *MockTxOrmer) RollbackUnlessCommit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackUnlessCommit")
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackUnlessCommit indicates an expected call of RollbackUnlessCommit.
func (mr *MockTxOrmerMockRecorder) RollbackUnlessCommit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackUnlessCommit", reflect.TypeOf((*MockTxOrmer)(nil).RollbackUnlessCommit))
}

// Update mocks base method.
func (m *MockTxOrmer) Update(md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockTxOrmerMockRecorder) Update(md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTxOrmer)(nil).Update), varargs...)
}

// UpdateWithCtx mocks base method.
func (m *MockTxOrmer) UpdateWithCtx(ctx context.Context, md interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, md}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx.
func (mr *MockTxOrmerMockRecorder) UpdateWithCtx(ctx, md interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, md}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*MockTxOrmer)(nil).UpdateWithCtx), varargs...)
}

// MockInserter is a mock of Inserter interface.
type MockInserter struct {
	ctrl     *gomock.Controller
	recorder *MockInserterMockRecorder
}

// MockInserterMockRecorder is the mock recorder for MockInserter.
type MockInserterMockRecorder struct {
	mock *MockInserter
}

// NewMockInserter creates a new mock instance.
func NewMockInserter(ctrl *gomock.Controller) *MockInserter {
	mock := &MockInserter{ctrl: ctrl}
	mock.recorder = &MockInserterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInserter) EXPECT() *MockInserterMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockInserter) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockInserterMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockInserter)(nil).Close))
}

// Insert mocks base method.
func (m *MockInserter) Insert(arg0 interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockInserterMockRecorder) Insert(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockInserter)(nil).Insert), arg0)
}

// InsertWithCtx mocks base method.
func (m *MockInserter) InsertWithCtx(arg0 context.Context, arg1 interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertWithCtx", arg0, arg1)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx.
func (mr *MockInserterMockRecorder) InsertWithCtx(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*MockInserter)(nil).InsertWithCtx), arg0, arg1)
}

// MockQuerySeter is a mock of QuerySeter interface.
type MockQuerySeter struct {
	ctrl     *gomock.Controller
	recorder *MockQuerySeterMockRecorder
}

// MockQuerySeterMockRecorder is the mock recorder for MockQuerySeter.
type MockQuerySeterMockRecorder struct {
	mock *MockQuerySeter
}

// NewMockQuerySeter creates a new mock instance.
func NewMockQuerySeter(ctrl *gomock.Controller) *MockQuerySeter {
	mock := &MockQuerySeter{ctrl: ctrl}
	mock.recorder = &MockQuerySeterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerySeter) EXPECT() *MockQuerySeterMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockQuerySeter) Aggregate(s string) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Aggregate", s)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockQuerySeterMockRecorder) Aggregate(s interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockQuerySeter)(nil).Aggregate), s)
}

// All mocks base method.
func (m *MockQuerySeter) All(container interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "All", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// All indicates an expected call of All.
func (mr *MockQuerySeterMockRecorder) All(container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockQuerySeter)(nil).All), varargs...)
}

// AllWithCtx mocks base method.
func (m *MockQuerySeter) AllWithCtx(ctx context.Context, container interface{}, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AllWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AllWithCtx indicates an expected call of AllWithCtx.
func (mr *MockQuerySeterMockRecorder) AllWithCtx(ctx, container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).AllWithCtx), varargs...)
}

// Count mocks base method.
func (m *MockQuerySeter) Count() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockQuerySeterMockRecorder) Count() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockQuerySeter)(nil).Count))
}

// CountWithCtx mocks base method.
func (m *MockQuerySeter) CountWithCtx(arg0 context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountWithCtx", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountWithCtx indicates an expected call of CountWithCtx.
func (mr *MockQuerySeterMockRecorder) CountWithCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).CountWithCtx), arg0)
}

// Delete mocks base method.
func (m *MockQuerySeter) Delete() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockQuerySeterMockRecorder) Delete() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockQuerySeter)(nil).Delete))
}

// DeleteWithCtx mocks base method.
func (m *MockQuerySeter) DeleteWithCtx(arg0 context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteWithCtx", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx.
func (mr *MockQuerySeterMockRecorder) DeleteWithCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).DeleteWithCtx), arg0)
}

// Distinct mocks base method.
func (m *MockQuerySeter) Distinct() QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Distinct")
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// Distinct indicates an expected call of Distinct.
func (mr *MockQuerySeterMockRecorder) Distinct() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Distinct", reflect.TypeOf((*MockQuerySeter)(nil).Distinct))
}

// Exclude mocks base method.
func (m *MockQuerySeter) Exclude(arg0 string, arg1 ...interface{}) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exclude", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// Exclude indicates an expected call of Exclude.
func (mr *MockQuerySeterMockRecorder) Exclude(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exclude", reflect.TypeOf((*MockQuerySeter)(nil).Exclude), varargs...)
}

// Exist mocks base method.
func (m *MockQuerySeter) Exist() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exist indicates an expected call of Exist.
func (mr *MockQuerySeterMockRecorder) Exist() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockQuerySeter)(nil).Exist))
}

// ExistWithCtx mocks base method.
func (m *MockQuerySeter) ExistWithCtx(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistWithCtx", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ExistWithCtx indicates an expected call of ExistWithCtx.
func (mr *MockQuerySeterMockRecorder) ExistWithCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).ExistWithCtx), arg0)
}

// Filter mocks base method.
func (m *MockQuerySeter) Filter(arg0 string, arg1 ...interface{}) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Filter", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// Filter indicates an expected call of Filter.
func (mr *MockQuerySeterMockRecorder) Filter(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Filter", reflect.TypeOf((*MockQuerySeter)(nil).Filter), varargs...)
}

// FilterRaw mocks base method.
func (m *MockQuerySeter) FilterRaw(arg0, arg1 string) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterRaw", arg0, arg1)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// FilterRaw indicates an expected call of FilterRaw.
func (mr *MockQuerySeterMockRecorder) FilterRaw(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterRaw", reflect.TypeOf((*MockQuerySeter)(nil).FilterRaw), arg0, arg1)
}

// ForUpdate mocks base method.
func (m *MockQuerySeter) ForUpdate() QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForUpdate")
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// ForUpdate indicates an expected call of ForUpdate.
func (mr *MockQuerySeterMockRecorder) ForUpdate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForUpdate", reflect.TypeOf((*MockQuerySeter)(nil).ForUpdate))
}

// ForceIndex mocks base method.
func (m *MockQuerySeter) ForceIndex(indexes ...string) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range indexes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ForceIndex", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// ForceIndex indicates an expected call of ForceIndex.
func (mr *MockQuerySeterMockRecorder) ForceIndex(indexes ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForceIndex", reflect.TypeOf((*MockQuerySeter)(nil).ForceIndex), indexes...)
}

// GetCond mocks base method.
func (m *MockQuerySeter) GetCond() *Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCond")
	ret0, _ := ret[0].(*Condition)
	return ret0
}

// GetCond indicates an expected call of GetCond.
func (mr *MockQuerySeterMockRecorder) GetCond() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCond", reflect.TypeOf((*MockQuerySeter)(nil).GetCond))
}

// GroupBy mocks base method.
func (m *MockQuerySeter) GroupBy(exprs ...string) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range exprs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GroupBy", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// GroupBy indicates an expected call of GroupBy.
func (mr *MockQuerySeterMockRecorder) GroupBy(exprs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupBy", reflect.TypeOf((*MockQuerySeter)(nil).GroupBy), exprs...)
}

// IgnoreIndex mocks base method.
func (m *MockQuerySeter) IgnoreIndex(indexes ...string) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range indexes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IgnoreIndex", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// IgnoreIndex indicates an expected call of IgnoreIndex.
func (mr *MockQuerySeterMockRecorder) IgnoreIndex(indexes ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IgnoreIndex", reflect.TypeOf((*MockQuerySeter)(nil).IgnoreIndex), indexes...)
}

// Limit mocks base method.
func (m *MockQuerySeter) Limit(limit interface{}, args ...interface{}) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{limit}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Limit", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// Limit indicates an expected call of Limit.
func (mr *MockQuerySeterMockRecorder) Limit(limit interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{limit}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Limit", reflect.TypeOf((*MockQuerySeter)(nil).Limit), varargs...)
}

// Offset mocks base method.
func (m *MockQuerySeter) Offset(offset interface{}) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Offset", offset)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// Offset indicates an expected call of Offset.
func (mr *MockQuerySeterMockRecorder) Offset(offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Offset", reflect.TypeOf((*MockQuerySeter)(nil).Offset), offset)
}

// One mocks base method.
func (m *MockQuerySeter) One(container interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "One", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// One indicates an expected call of One.
func (mr *MockQuerySeterMockRecorder) One(container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "One", reflect.TypeOf((*MockQuerySeter)(nil).One), varargs...)
}

// OneWithCtx mocks base method.
func (m *MockQuerySeter) OneWithCtx(ctx context.Context, container interface{}, cols ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OneWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// OneWithCtx indicates an expected call of OneWithCtx.
func (mr *MockQuerySeterMockRecorder) OneWithCtx(ctx, container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OneWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).OneWithCtx), varargs...)
}

// OrderBy mocks base method.
func (m *MockQuerySeter) OrderBy(exprs ...string) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range exprs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OrderBy", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// OrderBy indicates an expected call of OrderBy.
func (mr *MockQuerySeterMockRecorder) OrderBy(exprs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrderBy", reflect.TypeOf((*MockQuerySeter)(nil).OrderBy), exprs...)
}

// OrderClauses mocks base method.
func (m *MockQuerySeter) OrderClauses(orders ...*order_clause.Order) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range orders {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OrderClauses", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// OrderClauses indicates an expected call of OrderClauses.
func (mr *MockQuerySeterMockRecorder) OrderClauses(orders ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrderClauses", reflect.TypeOf((*MockQuerySeter)(nil).OrderClauses), orders...)
}

// PrepareInsert mocks base method.
func (m *MockQuerySeter) PrepareInsert() (Inserter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareInsert")
	ret0, _ := ret[0].(Inserter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareInsert indicates an expected call of PrepareInsert.
func (mr *MockQuerySeterMockRecorder) PrepareInsert() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareInsert", reflect.TypeOf((*MockQuerySeter)(nil).PrepareInsert))
}

// PrepareInsertWithCtx mocks base method.
func (m *MockQuerySeter) PrepareInsertWithCtx(arg0 context.Context) (Inserter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareInsertWithCtx", arg0)
	ret0, _ := ret[0].(Inserter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareInsertWithCtx indicates an expected call of PrepareInsertWithCtx.
func (mr *MockQuerySeterMockRecorder) PrepareInsertWithCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareInsertWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).PrepareInsertWithCtx), arg0)
}

// RelatedSel mocks base method.
func (m *MockQuerySeter) RelatedSel(params ...interface{}) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RelatedSel", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// RelatedSel indicates an expected call of RelatedSel.
func (mr *MockQuerySeterMockRecorder) RelatedSel(params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RelatedSel", reflect.TypeOf((*MockQuerySeter)(nil).RelatedSel), params...)
}

// RowsToMap mocks base method.
func (m *MockQuerySeter) RowsToMap(result *Params, keyCol, valueCol string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsToMap", result, keyCol, valueCol)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsToMap indicates an expected call of RowsToMap.
func (mr *MockQuerySeterMockRecorder) RowsToMap(result, keyCol, valueCol interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsToMap", reflect.TypeOf((*MockQuerySeter)(nil).RowsToMap), result, keyCol, valueCol)
}

// RowsToStruct mocks base method.
func (m *MockQuerySeter) RowsToStruct(ptrStruct interface{}, keyCol, valueCol string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsToStruct", ptrStruct, keyCol, valueCol)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsToStruct indicates an expected call of RowsToStruct.
func (mr *MockQuerySeterMockRecorder) RowsToStruct(ptrStruct, keyCol, valueCol interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsToStruct", reflect.TypeOf((*MockQuerySeter)(nil).RowsToStruct), ptrStruct, keyCol, valueCol)
}

// SetCond mocks base method.
func (m *MockQuerySeter) SetCond(arg0 *Condition) QuerySeter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCond", arg0)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// SetCond indicates an expected call of SetCond.
func (mr *MockQuerySeterMockRecorder) SetCond(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCond", reflect.TypeOf((*MockQuerySeter)(nil).SetCond), arg0)
}

// Update mocks base method.
func (m *MockQuerySeter) Update(values Params) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", values)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockQuerySeterMockRecorder) Update(values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockQuerySeter)(nil).Update), values)
}

// UpdateWithCtx mocks base method.
func (m *MockQuerySeter) UpdateWithCtx(ctx context.Context, values Params) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWithCtx", ctx, values)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx.
func (mr *MockQuerySeterMockRecorder) UpdateWithCtx(ctx, values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).UpdateWithCtx), ctx, values)
}

// UseIndex mocks base method.
func (m *MockQuerySeter) UseIndex(indexes ...string) QuerySeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range indexes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UseIndex", varargs...)
	ret0, _ := ret[0].(QuerySeter)
	return ret0
}

// UseIndex indicates an expected call of UseIndex.
func (mr *MockQuerySeterMockRecorder) UseIndex(indexes ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UseIndex", reflect.TypeOf((*MockQuerySeter)(nil).UseIndex), indexes...)
}

// Values mocks base method.
func (m *MockQuerySeter) Values(results *[]Params, exprs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{results}
	for _, a := range exprs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Values", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Values indicates an expected call of Values.
func (mr *MockQuerySeterMockRecorder) Values(results interface{}, exprs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{results}, exprs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Values", reflect.TypeOf((*MockQuerySeter)(nil).Values), varargs...)
}

// ValuesFlat mocks base method.
func (m *MockQuerySeter) ValuesFlat(result *ParamsList, expr string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValuesFlat", result, expr)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesFlat indicates an expected call of ValuesFlat.
func (mr *MockQuerySeterMockRecorder) ValuesFlat(result, expr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesFlat", reflect.TypeOf((*MockQuerySeter)(nil).ValuesFlat), result, expr)
}

// ValuesFlatWithCtx mocks base method.
func (m *MockQuerySeter) ValuesFlatWithCtx(ctx context.Context, result *ParamsList, expr string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValuesFlatWithCtx", ctx, result, expr)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesFlatWithCtx indicates an expected call of ValuesFlatWithCtx.
func (mr *MockQuerySeterMockRecorder) ValuesFlatWithCtx(ctx, result, expr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesFlatWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).ValuesFlatWithCtx), ctx, result, expr)
}

// ValuesList mocks base method.
func (m *MockQuerySeter) ValuesList(results *[]ParamsList, exprs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{results}
	for _, a := range exprs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValuesList", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesList indicates an expected call of ValuesList.
func (mr *MockQuerySeterMockRecorder) ValuesList(results interface{}, exprs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{results}, exprs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesList", reflect.TypeOf((*MockQuerySeter)(nil).ValuesList), varargs...)
}

// ValuesListWithCtx mocks base method.
func (m *MockQuerySeter) ValuesListWithCtx(ctx context.Context, results *[]ParamsList, exprs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, results}
	for _, a := range exprs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValuesListWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesListWithCtx indicates an expected call of ValuesListWithCtx.
func (mr *MockQuerySeterMockRecorder) ValuesListWithCtx(ctx, results interface{}, exprs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, results}, exprs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesListWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).ValuesListWithCtx), varargs...)
}

// ValuesWithCtx mocks base method.
func (m *MockQuerySeter) ValuesWithCtx(ctx context.Context, results *[]Params, exprs ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, results}
	for _, a := range exprs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValuesWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesWithCtx indicates an expected call of ValuesWithCtx.
func (mr *MockQuerySeterMockRecorder) ValuesWithCtx(ctx, results interface{}, exprs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, results}, exprs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesWithCtx", reflect.TypeOf((*MockQuerySeter)(nil).ValuesWithCtx), varargs...)
}

// MockQueryM2Mer is a mock of QueryM2Mer interface.
type MockQueryM2Mer struct {
	ctrl     *gomock.Controller
	recorder *MockQueryM2MerMockRecorder
}

// MockQueryM2MerMockRecorder is the mock recorder for MockQueryM2Mer.
type MockQueryM2MerMockRecorder struct {
	mock *MockQueryM2Mer
}

// NewMockQueryM2Mer creates a new mock instance.
func NewMockQueryM2Mer(ctrl *gomock.Controller) *MockQueryM2Mer {
	mock := &MockQueryM2Mer{ctrl: ctrl}
	mock.recorder = &MockQueryM2MerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryM2Mer) EXPECT() *MockQueryM2MerMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockQueryM2Mer) Add(arg0 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Add", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Add indicates an expected call of Add.
func (mr *MockQueryM2MerMockRecorder) Add(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockQueryM2Mer)(nil).Add), arg0...)
}

// AddWithCtx mocks base method.
func (m *MockQueryM2Mer) AddWithCtx(arg0 context.Context, arg1 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddWithCtx indicates an expected call of AddWithCtx.
func (mr *MockQueryM2MerMockRecorder) AddWithCtx(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddWithCtx", reflect.TypeOf((*MockQueryM2Mer)(nil).AddWithCtx), varargs...)
}

// Clear mocks base method.
func (m *MockQueryM2Mer) Clear() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Clear")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Clear indicates an expected call of Clear.
func (mr *MockQueryM2MerMockRecorder) Clear() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockQueryM2Mer)(nil).Clear))
}

// ClearWithCtx mocks base method.
func (m *MockQueryM2Mer) ClearWithCtx(arg0 context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClearWithCtx", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ClearWithCtx indicates an expected call of ClearWithCtx.
func (mr *MockQueryM2MerMockRecorder) ClearWithCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearWithCtx", reflect.TypeOf((*MockQueryM2Mer)(nil).ClearWithCtx), arg0)
}

// Count mocks base method.
func (m *MockQueryM2Mer) Count() (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockQueryM2MerMockRecorder) Count() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockQueryM2Mer)(nil).Count))
}

// CountWithCtx mocks base method.
func (m *MockQueryM2Mer) CountWithCtx(arg0 context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountWithCtx", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountWithCtx indicates an expected call of CountWithCtx.
func (mr *MockQueryM2MerMockRecorder) CountWithCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountWithCtx", reflect.TypeOf((*MockQueryM2Mer)(nil).CountWithCtx), arg0)
}

// Exist mocks base method.
func (m *MockQueryM2Mer) Exist(arg0 interface{}) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exist indicates an expected call of Exist.
func (mr *MockQueryM2MerMockRecorder) Exist(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockQueryM2Mer)(nil).Exist), arg0)
}

// ExistWithCtx mocks base method.
func (m *MockQueryM2Mer) ExistWithCtx(arg0 context.Context, arg1 interface{}) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistWithCtx", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ExistWithCtx indicates an expected call of ExistWithCtx.
func (mr *MockQueryM2MerMockRecorder) ExistWithCtx(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistWithCtx", reflect.TypeOf((*MockQueryM2Mer)(nil).ExistWithCtx), arg0, arg1)
}

// Remove mocks base method.
func (m *MockQueryM2Mer) Remove(arg0 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Remove", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Remove indicates an expected call of Remove.
func (mr *MockQueryM2MerMockRecorder) Remove(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockQueryM2Mer)(nil).Remove), arg0...)
}

// RemoveWithCtx mocks base method.
func (m *MockQueryM2Mer) RemoveWithCtx(arg0 context.Context, arg1 ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoveWithCtx indicates an expected call of RemoveWithCtx.
func (mr *MockQueryM2MerMockRecorder) RemoveWithCtx(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithCtx", reflect.TypeOf((*MockQueryM2Mer)(nil).RemoveWithCtx), varargs...)
}

// MockRawPreparer is a mock of RawPreparer interface.
type MockRawPreparer struct {
	ctrl     *gomock.Controller
	recorder *MockRawPreparerMockRecorder
}

// MockRawPreparerMockRecorder is the mock recorder for MockRawPreparer.
type MockRawPreparerMockRecorder struct {
	mock *MockRawPreparer
}

// NewMockRawPreparer creates a new mock instance.
func NewMockRawPreparer(ctrl *gomock.Controller) *MockRawPreparer {
	mock := &MockRawPreparer{ctrl: ctrl}
	mock.recorder = &MockRawPreparerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRawPreparer) EXPECT() *MockRawPreparerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockRawPreparer) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockRawPreparerMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRawPreparer)(nil).Close))
}

// Exec mocks base method.
func (m *MockRawPreparer) Exec(arg0 ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockRawPreparerMockRecorder) Exec(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockRawPreparer)(nil).Exec), arg0...)
}

// MockRawSeter is a mock of RawSeter interface.
type MockRawSeter struct {
	ctrl     *gomock.Controller
	recorder *MockRawSeterMockRecorder
}

// MockRawSeterMockRecorder is the mock recorder for MockRawSeter.
type MockRawSeterMockRecorder struct {
	mock *MockRawSeter
}

// NewMockRawSeter creates a new mock instance.
func NewMockRawSeter(ctrl *gomock.Controller) *MockRawSeter {
	mock := &MockRawSeter{ctrl: ctrl}
	mock.recorder = &MockRawSeterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRawSeter) EXPECT() *MockRawSeterMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockRawSeter) Exec() (sql.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec")
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockRawSeterMockRecorder) Exec() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockRawSeter)(nil).Exec))
}

// Prepare mocks base method.
func (m *MockRawSeter) Prepare() (RawPreparer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare")
	ret0, _ := ret[0].(RawPreparer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prepare indicates an expected call of Prepare.
func (mr *MockRawSeterMockRecorder) Prepare() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockRawSeter)(nil).Prepare))
}

// QueryRow mocks base method.
func (m *MockRawSeter) QueryRow(containers ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range containers {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockRawSeterMockRecorder) QueryRow(containers ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockRawSeter)(nil).QueryRow), containers...)
}

// QueryRows mocks base method.
func (m *MockRawSeter) QueryRows(containers ...interface{}) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range containers {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRows", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRows indicates an expected call of QueryRows.
func (mr *MockRawSeterMockRecorder) QueryRows(containers ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRows", reflect.TypeOf((*MockRawSeter)(nil).QueryRows), containers...)
}

// RowsToMap mocks base method.
func (m *MockRawSeter) RowsToMap(result *Params, keyCol, valueCol string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsToMap", result, keyCol, valueCol)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsToMap indicates an expected call of RowsToMap.
func (mr *MockRawSeterMockRecorder) RowsToMap(result, keyCol, valueCol interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsToMap", reflect.TypeOf((*MockRawSeter)(nil).RowsToMap), result, keyCol, valueCol)
}

// RowsToStruct mocks base method.
func (m *MockRawSeter) RowsToStruct(ptrStruct interface{}, keyCol, valueCol string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RowsToStruct", ptrStruct, keyCol, valueCol)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RowsToStruct indicates an expected call of RowsToStruct.
func (mr *MockRawSeterMockRecorder) RowsToStruct(ptrStruct, keyCol, valueCol interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RowsToStruct", reflect.TypeOf((*MockRawSeter)(nil).RowsToStruct), ptrStruct, keyCol, valueCol)
}

// SetArgs mocks base method.
func (m *MockRawSeter) SetArgs(arg0 ...interface{}) RawSeter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetArgs", varargs...)
	ret0, _ := ret[0].(RawSeter)
	return ret0
}

// SetArgs indicates an expected call of SetArgs.
func (mr *MockRawSeterMockRecorder) SetArgs(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetArgs", reflect.TypeOf((*MockRawSeter)(nil).SetArgs), arg0...)
}

// Values mocks base method.
func (m *MockRawSeter) Values(container *[]Params, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Values", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Values indicates an expected call of Values.
func (mr *MockRawSeterMockRecorder) Values(container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Values", reflect.TypeOf((*MockRawSeter)(nil).Values), varargs...)
}

// ValuesFlat mocks base method.
func (m *MockRawSeter) ValuesFlat(container *ParamsList, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValuesFlat", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesFlat indicates an expected call of ValuesFlat.
func (mr *MockRawSeterMockRecorder) ValuesFlat(container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesFlat", reflect.TypeOf((*MockRawSeter)(nil).ValuesFlat), varargs...)
}

// ValuesList mocks base method.
func (m *MockRawSeter) ValuesList(container *[]ParamsList, cols ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{container}
	for _, a := range cols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValuesList", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValuesList indicates an expected call of ValuesList.
func (mr *MockRawSeterMockRecorder) ValuesList(container interface{}, cols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{container}, cols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValuesList", reflect.TypeOf((*MockRawSeter)(nil).ValuesList), varargs...)
}

// MockstmtQuerier is a mock of stmtQuerier interface.
type MockstmtQuerier struct {
	ctrl     *gomock.Controller
	recorder *MockstmtQuerierMockRecorder
}

// MockstmtQuerierMockRecorder is the mock recorder for MockstmtQuerier.
type MockstmtQuerierMockRecorder struct {
	mock *MockstmtQuerier
}

// NewMockstmtQuerier creates a new mock instance.
func NewMockstmtQuerier(ctrl *gomock.Controller) *MockstmtQuerier {
	mock := &MockstmtQuerier{ctrl: ctrl}
	mock.recorder = &MockstmtQuerierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockstmtQuerier) EXPECT() *MockstmtQuerierMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockstmtQuerier) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockstmtQuerierMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockstmtQuerier)(nil).Close))
}

// Exec mocks base method.
func (m *MockstmtQuerier) Exec(args ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockstmtQuerierMockRecorder) Exec(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockstmtQuerier)(nil).Exec), args...)
}

// ExecContext mocks base method.
func (m *MockstmtQuerier) ExecContext(ctx context.Context, args ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockstmtQuerierMockRecorder) ExecContext(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockstmtQuerier)(nil).ExecContext), varargs...)
}

// Query mocks base method.
func (m *MockstmtQuerier) Query(args ...interface{}) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockstmtQuerierMockRecorder) Query(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockstmtQuerier)(nil).Query), args...)
}

// QueryContext mocks base method.
func (m *MockstmtQuerier) QueryContext(ctx context.Context, args ...interface{}) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockstmtQuerierMockRecorder) QueryContext(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockstmtQuerier)(nil).QueryContext), varargs...)
}

// QueryRow mocks base method.
func (m *MockstmtQuerier) QueryRow(args ...interface{}) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockstmtQuerierMockRecorder) QueryRow(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockstmtQuerier)(nil).QueryRow), args...)
}

// QueryRowContext mocks base method.
func (m *MockstmtQuerier) QueryRowContext(ctx context.Context, args ...interface{}) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRowContext", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRowContext indicates an expected call of QueryRowContext.
func (mr *MockstmtQuerierMockRecorder) QueryRowContext(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowContext", reflect.TypeOf((*MockstmtQuerier)(nil).QueryRowContext), varargs...)
}

// MockdbQuerier is a mock of dbQuerier interface.
type MockdbQuerier struct {
	ctrl     *gomock.Controller
	recorder *MockdbQuerierMockRecorder
}

// MockdbQuerierMockRecorder is the mock recorder for MockdbQuerier.
type MockdbQuerierMockRecorder struct {
	mock *MockdbQuerier
}

// NewMockdbQuerier creates a new mock instance.
func NewMockdbQuerier(ctrl *gomock.Controller) *MockdbQuerier {
	mock := &MockdbQuerier{ctrl: ctrl}
	mock.recorder = &MockdbQuerierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockdbQuerier) EXPECT() *MockdbQuerierMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockdbQuerier) Exec(query string, args ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockdbQuerierMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockdbQuerier)(nil).Exec), varargs...)
}

// ExecContext mocks base method.
func (m *MockdbQuerier) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecContext indicates an expected call of ExecContext.
func (mr *MockdbQuerierMockRecorder) ExecContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockdbQuerier)(nil).ExecContext), varargs...)
}

// Prepare mocks base method.
func (m *MockdbQuerier) Prepare(query string) (*sql.Stmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", query)
	ret0, _ := ret[0].(*sql.Stmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prepare indicates an expected call of Prepare.
func (mr *MockdbQuerierMockRecorder) Prepare(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockdbQuerier)(nil).Prepare), query)
}

// PrepareContext mocks base method.
func (m *MockdbQuerier) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareContext", ctx, query)
	ret0, _ := ret[0].(*sql.Stmt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareContext indicates an expected call of PrepareContext.
func (mr *MockdbQuerierMockRecorder) PrepareContext(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareContext", reflect.TypeOf((*MockdbQuerier)(nil).PrepareContext), ctx, query)
}

// Query mocks base method.
func (m *MockdbQuerier) Query(query string, args ...interface{}) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockdbQuerierMockRecorder) Query(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockdbQuerier)(nil).Query), varargs...)
}

// QueryContext mocks base method.
func (m *MockdbQuerier) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryContext indicates an expected call of QueryContext.
func (mr *MockdbQuerierMockRecorder) QueryContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockdbQuerier)(nil).QueryContext), varargs...)
}

// QueryRow mocks base method.
func (m *MockdbQuerier) QueryRow(query string, args ...interface{}) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockdbQuerierMockRecorder) QueryRow(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockdbQuerier)(nil).QueryRow), varargs...)
}

// QueryRowContext mocks base method.
func (m *MockdbQuerier) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRowContext", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// QueryRowContext indicates an expected call of QueryRowContext.
func (mr *MockdbQuerierMockRecorder) QueryRowContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowContext", reflect.TypeOf((*MockdbQuerier)(nil).QueryRowContext), varargs...)
}

// MockdbBaser is a mock of dbBaser interface.
type MockdbBaser struct {
	ctrl     *gomock.Controller
	recorder *MockdbBaserMockRecorder
}

// MockdbBaserMockRecorder is the mock recorder for MockdbBaser.
type MockdbBaserMockRecorder struct {
	mock *MockdbBaser
}

// NewMockdbBaser creates a new mock instance.
func NewMockdbBaser(ctrl *gomock.Controller) *MockdbBaser {
	mock := &MockdbBaser{ctrl: ctrl}
	mock.recorder = &MockdbBaserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockdbBaser) EXPECT() *MockdbBaserMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockdbBaser) Count(arg0 context.Context, arg1 dbQuerier, arg2 querySet, arg3 *models.ModelInfo, arg4 *Condition, arg5 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockdbBaserMockRecorder) Count(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockdbBaser)(nil).Count), arg0, arg1, arg2, arg3, arg4, arg5)
}

// DbTypes mocks base method.
func (m *MockdbBaser) DbTypes() map[string]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DbTypes")
	ret0, _ := ret[0].(map[string]string)
	return ret0
}

// DbTypes indicates an expected call of DbTypes.
func (mr *MockdbBaserMockRecorder) DbTypes() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DbTypes", reflect.TypeOf((*MockdbBaser)(nil).DbTypes))
}

// Delete mocks base method.
func (m *MockdbBaser) Delete(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 *time.Location, arg5 []string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockdbBaserMockRecorder) Delete(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockdbBaser)(nil).Delete), arg0, arg1, arg2, arg3, arg4, arg5)
}

// DeleteBatch mocks base method.
func (m *MockdbBaser) DeleteBatch(arg0 context.Context, arg1 dbQuerier, arg2 *querySet, arg3 *models.ModelInfo, arg4 *Condition, arg5 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteBatch", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteBatch indicates an expected call of DeleteBatch.
func (mr *MockdbBaserMockRecorder) DeleteBatch(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBatch", reflect.TypeOf((*MockdbBaser)(nil).DeleteBatch), arg0, arg1, arg2, arg3, arg4, arg5)
}

// ExecRaw mocks base method.
func (m *MockdbBaser) ExecRaw(ctx context.Context, q dbQuerier, query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, q, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecRaw", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecRaw indicates an expected call of ExecRaw.
func (mr *MockdbBaserMockRecorder) ExecRaw(ctx, q, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, q, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecRaw", reflect.TypeOf((*MockdbBaser)(nil).ExecRaw), varargs...)
}

// GenerateOperatorLeftCol mocks base method.
func (m *MockdbBaser) GenerateOperatorLeftCol(arg0 *models.FieldInfo, arg1 string, arg2 *string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "GenerateOperatorLeftCol", arg0, arg1, arg2)
}

// GenerateOperatorLeftCol indicates an expected call of GenerateOperatorLeftCol.
func (mr *MockdbBaserMockRecorder) GenerateOperatorLeftCol(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateOperatorLeftCol", reflect.TypeOf((*MockdbBaser)(nil).GenerateOperatorLeftCol), arg0, arg1, arg2)
}

// GenerateOperatorSQL mocks base method.
func (m *MockdbBaser) GenerateOperatorSQL(arg0 *models.ModelInfo, arg1 *models.FieldInfo, arg2 string, arg3 []interface{}, arg4 *time.Location) (string, []interface{}) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateOperatorSQL", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].([]interface{})
	return ret0, ret1
}

// GenerateOperatorSQL indicates an expected call of GenerateOperatorSQL.
func (mr *MockdbBaserMockRecorder) GenerateOperatorSQL(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateOperatorSQL", reflect.TypeOf((*MockdbBaser)(nil).GenerateOperatorSQL), arg0, arg1, arg2, arg3, arg4)
}

// GenerateSpecifyIndex mocks base method.
func (m *MockdbBaser) GenerateSpecifyIndex(tableName string, useIndex int, indexes []string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateSpecifyIndex", tableName, useIndex, indexes)
	ret0, _ := ret[0].(string)
	return ret0
}

// GenerateSpecifyIndex indicates an expected call of GenerateSpecifyIndex.
func (mr *MockdbBaserMockRecorder) GenerateSpecifyIndex(tableName, useIndex, indexes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateSpecifyIndex", reflect.TypeOf((*MockdbBaser)(nil).GenerateSpecifyIndex), tableName, useIndex, indexes)
}

// GetColumns mocks base method.
func (m *MockdbBaser) GetColumns(arg0 context.Context, arg1 dbQuerier, arg2 string) (map[string][3]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetColumns", arg0, arg1, arg2)
	ret0, _ := ret[0].(map[string][3]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetColumns indicates an expected call of GetColumns.
func (mr *MockdbBaserMockRecorder) GetColumns(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetColumns", reflect.TypeOf((*MockdbBaser)(nil).GetColumns), arg0, arg1, arg2)
}

// GetTables mocks base method.
func (m *MockdbBaser) GetTables(arg0 dbQuerier) (map[string]bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTables", arg0)
	ret0, _ := ret[0].(map[string]bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTables indicates an expected call of GetTables.
func (mr *MockdbBaserMockRecorder) GetTables(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTables", reflect.TypeOf((*MockdbBaser)(nil).GetTables), arg0)
}

// HasReturningID mocks base method.
func (m *MockdbBaser) HasReturningID(arg0 *models.ModelInfo, arg1 *string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasReturningID", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasReturningID indicates an expected call of HasReturningID.
func (mr *MockdbBaserMockRecorder) HasReturningID(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasReturningID", reflect.TypeOf((*MockdbBaser)(nil).HasReturningID), arg0, arg1)
}

// IndexExists mocks base method.
func (m *MockdbBaser) IndexExists(arg0 context.Context, arg1 dbQuerier, arg2, arg3 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexExists", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IndexExists indicates an expected call of IndexExists.
func (mr *MockdbBaserMockRecorder) IndexExists(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexExists", reflect.TypeOf((*MockdbBaser)(nil).IndexExists), arg0, arg1, arg2, arg3)
}

// Insert mocks base method.
func (m *MockdbBaser) Insert(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockdbBaserMockRecorder) Insert(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockdbBaser)(nil).Insert), arg0, arg1, arg2, arg3, arg4)
}

// InsertMulti mocks base method.
func (m *MockdbBaser) InsertMulti(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 int, arg5 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertMulti", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti.
func (mr *MockdbBaserMockRecorder) InsertMulti(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*MockdbBaser)(nil).InsertMulti), arg0, arg1, arg2, arg3, arg4, arg5)
}

// InsertOrUpdate mocks base method.
func (m *MockdbBaser) InsertOrUpdate(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 *alias, arg5 ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate.
func (mr *MockdbBaserMockRecorder) InsertOrUpdate(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*MockdbBaser)(nil).InsertOrUpdate), varargs...)
}

// InsertStmt mocks base method.
func (m *MockdbBaser) InsertStmt(arg0 context.Context, arg1 stmtQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertStmt", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertStmt indicates an expected call of InsertStmt.
func (mr *MockdbBaserMockRecorder) InsertStmt(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertStmt", reflect.TypeOf((*MockdbBaser)(nil).InsertStmt), arg0, arg1, arg2, arg3, arg4)
}

// InsertValue mocks base method.
func (m *MockdbBaser) InsertValue(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 bool, arg4 []string, arg5 []interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertValue", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertValue indicates an expected call of InsertValue.
func (mr *MockdbBaserMockRecorder) InsertValue(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertValue", reflect.TypeOf((*MockdbBaser)(nil).InsertValue), arg0, arg1, arg2, arg3, arg4, arg5)
}

// MaxLimit mocks base method.
func (m *MockdbBaser) MaxLimit() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaxLimit")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// MaxLimit indicates an expected call of MaxLimit.
func (mr *MockdbBaserMockRecorder) MaxLimit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaxLimit", reflect.TypeOf((*MockdbBaser)(nil).MaxLimit))
}

// OperatorSQL mocks base method.
func (m *MockdbBaser) OperatorSQL(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OperatorSQL", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}

// OperatorSQL indicates an expected call of OperatorSQL.
func (mr *MockdbBaserMockRecorder) OperatorSQL(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OperatorSQL", reflect.TypeOf((*MockdbBaser)(nil).OperatorSQL), arg0)
}

// PrepareInsert mocks base method.
func (m *MockdbBaser) PrepareInsert(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo) (stmtQuerier, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareInsert", arg0, arg1, arg2)
	ret0, _ := ret[0].(stmtQuerier)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// PrepareInsert indicates an expected call of PrepareInsert.
func (mr *MockdbBaserMockRecorder) PrepareInsert(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareInsert", reflect.TypeOf((*MockdbBaser)(nil).PrepareInsert), arg0, arg1, arg2)
}

// Read mocks base method.
func (m *MockdbBaser) Read(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 *time.Location, arg5 []string, arg6 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read.
func (mr *MockdbBaserMockRecorder) Read(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockdbBaser)(nil).Read), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// ReadBatch mocks base method.
func (m *MockdbBaser) ReadBatch(arg0 context.Context, arg1 dbQuerier, arg2 querySet, arg3 *models.ModelInfo, arg4 *Condition, arg5 interface{}, arg6 *time.Location, arg7 []string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadBatch", arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadBatch indicates an expected call of ReadBatch.
func (mr *MockdbBaserMockRecorder) ReadBatch(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadBatch", reflect.TypeOf((*MockdbBaser)(nil).ReadBatch), arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// ReadRaw mocks base method.
func (m *MockdbBaser) ReadRaw(ctx context.Context, q dbQuerier, mi *models.ModelInfo, ind reflect.Value, tz *time.Location, query string, args ...any) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, q, mi, ind, tz, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadRaw", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadRaw indicates an expected call of ReadRaw.
func (mr *MockdbBaserMockRecorder) ReadRaw(ctx, q, mi, ind, tz, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, q, mi, ind, tz, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadRaw", reflect.TypeOf((*MockdbBaser)(nil).ReadRaw), varargs...)
}

// ReadValues mocks base method.
func (m *MockdbBaser) ReadValues(arg0 context.Context, arg1 dbQuerier, arg2 querySet, arg3 *models.ModelInfo, arg4 *Condition, arg5 []string, arg6 interface{}, arg7 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadValues", arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadValues indicates an expected call of ReadValues.
func (mr *MockdbBaserMockRecorder) ReadValues(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadValues", reflect.TypeOf((*MockdbBaser)(nil).ReadValues), arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// ReplaceMarks mocks base method.
func (m *MockdbBaser) ReplaceMarks(arg0 *string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReplaceMarks", arg0)
}

// ReplaceMarks indicates an expected call of ReplaceMarks.
func (mr *MockdbBaserMockRecorder) ReplaceMarks(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplaceMarks", reflect.TypeOf((*MockdbBaser)(nil).ReplaceMarks), arg0)
}

// ShowColumnsQuery mocks base method.
func (m *MockdbBaser) ShowColumnsQuery(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShowColumnsQuery", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}

// ShowColumnsQuery indicates an expected call of ShowColumnsQuery.
func (mr *MockdbBaserMockRecorder) ShowColumnsQuery(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShowColumnsQuery", reflect.TypeOf((*MockdbBaser)(nil).ShowColumnsQuery), arg0)
}

// ShowTablesQuery mocks base method.
func (m *MockdbBaser) ShowTablesQuery() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShowTablesQuery")
	ret0, _ := ret[0].(string)
	return ret0
}

// ShowTablesQuery indicates an expected call of ShowTablesQuery.
func (mr *MockdbBaserMockRecorder) ShowTablesQuery() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShowTablesQuery", reflect.TypeOf((*MockdbBaser)(nil).ShowTablesQuery))
}

// SupportUpdateJoin mocks base method.
func (m *MockdbBaser) SupportUpdateJoin() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportUpdateJoin")
	ret0, _ := ret[0].(bool)
	return ret0
}

// SupportUpdateJoin indicates an expected call of SupportUpdateJoin.
func (mr *MockdbBaserMockRecorder) SupportUpdateJoin() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportUpdateJoin", reflect.TypeOf((*MockdbBaser)(nil).SupportUpdateJoin))
}

// TableQuote mocks base method.
func (m *MockdbBaser) TableQuote() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TableQuote")
	ret0, _ := ret[0].(string)
	return ret0
}

// TableQuote indicates an expected call of TableQuote.
func (mr *MockdbBaserMockRecorder) TableQuote() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TableQuote", reflect.TypeOf((*MockdbBaser)(nil).TableQuote))
}

// TimeFromDB mocks base method.
func (m *MockdbBaser) TimeFromDB(arg0 *time.Time, arg1 *time.Location) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "TimeFromDB", arg0, arg1)
}

// TimeFromDB indicates an expected call of TimeFromDB.
func (mr *MockdbBaserMockRecorder) TimeFromDB(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimeFromDB", reflect.TypeOf((*MockdbBaser)(nil).TimeFromDB), arg0, arg1)
}

// TimeToDB mocks base method.
func (m *MockdbBaser) TimeToDB(arg0 *time.Time, arg1 *time.Location) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "TimeToDB", arg0, arg1)
}

// TimeToDB indicates an expected call of TimeToDB.
func (mr *MockdbBaserMockRecorder) TimeToDB(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimeToDB", reflect.TypeOf((*MockdbBaser)(nil).TimeToDB), arg0, arg1)
}

// Update mocks base method.
func (m *MockdbBaser) Update(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 reflect.Value, arg4 *time.Location, arg5 []string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", arg0, arg1, arg2, arg3, arg4, arg5)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockdbBaserMockRecorder) Update(arg0, arg1, arg2, arg3, arg4, arg5 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockdbBaser)(nil).Update), arg0, arg1, arg2, arg3, arg4, arg5)
}

// UpdateBatch mocks base method.
func (m *MockdbBaser) UpdateBatch(arg0 context.Context, arg1 dbQuerier, arg2 *querySet, arg3 *models.ModelInfo, arg4 *Condition, arg5 Params, arg6 *time.Location) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateBatch", arg0, arg1, arg2, arg3, arg4, arg5, arg6)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateBatch indicates an expected call of UpdateBatch.
func (mr *MockdbBaserMockRecorder) UpdateBatch(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBatch", reflect.TypeOf((*MockdbBaser)(nil).UpdateBatch), arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// collectFieldValue mocks base method.
func (m *MockdbBaser) collectFieldValue(arg0 *models.ModelInfo, arg1 *models.FieldInfo, arg2 reflect.Value, arg3 bool, arg4 *time.Location) (interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "collectFieldValue", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// collectFieldValue indicates an expected call of collectFieldValue.
func (mr *MockdbBaserMockRecorder) collectFieldValue(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "collectFieldValue", reflect.TypeOf((*MockdbBaser)(nil).collectFieldValue), arg0, arg1, arg2, arg3, arg4)
}

// setval mocks base method.
func (m *MockdbBaser) setval(arg0 context.Context, arg1 dbQuerier, arg2 *models.ModelInfo, arg3 []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "setval", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// setval indicates an expected call of setval.
func (mr *MockdbBaserMockRecorder) setval(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "setval", reflect.TypeOf((*MockdbBaser)(nil).setval), arg0, arg1, arg2, arg3)
}
